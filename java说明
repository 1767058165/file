由于J2EE是分布式程序平台，它以RMI机制实现程序组件在不同操作系统之间的通信。比如，一个EJB可以通过RMI调用Web上另一台机器上的EJB远程方法。
JNI是Java Native Interface的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C&C++）。从Java1.1开始，JNI标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。

rmi
int val = ((int) md5Bytes[i]) & 0xff;
下载安装java SE
Java应用服务器实质都是内置了某个版本的JDK
JRE是个运行环境，JDK是个开发环境。因此写Java程序的时候需要JDK，而运行Java程序的时候就需要JRE。而JDK里面已经包含了JRE，因此只要安装了JDK，就可以编辑Java程序，也可以正常运行Java程序。但由于JDK包含了许多与运行无关的内容，占用的空间较大，因此运行普通的Java程序无须安装JDK，而只需要安装JRE即可 [15]  。
Java程序是用类来组织的。
Java还包括一个类的扩展集合，分别组成各种程序包（Package），用户可以在自己的程序中使用。
*Java程序只要编写一次，就可到处运行。
*java容器
Java不支持指针，它消除重写存储和讹误数据的可能性。
Java是一个强类型语言，它允许扩展编译时检查潜在类型不匹配问题的功能。Java要求显式的方法声明
而Java运行系统用ANSIC语言编写。
*Java中的类是根据需要载入的，甚至有些是通过网络获取的。
main仅是解释器开始工作的地方，一个复杂的程序可能包含几十个类，但这些类仅需要一个main方法。
*因为相对而言，Java较安全
*即使是简单的 servlet，jsp和以struts为基础的网站在政府项目中也经常被用到。
编程工具
Eclipse：一个开放源代码的、基于Java的可扩展开发平台 [16]  。
NetBeans：开放源码的Java集成开发环境，适用于各种客户机和Web应用。
IntelliJ IDEA：在代码自动提示、代码分析等方面的具有很好的功能。 [17]
MyEclipse：由Genuitec公司开发的一款商业化软件，是应用比较广泛的Java应用程序集成开发环境 [18]  。
 *.class文件查看

Java SE(Java Platform,Standard Edition)，应该先说这个，因为这个是标准版本。
Java EE (Java Platform，Enterprise Edition)，java 的企业版本
Java ME(Java Platform，Micro Edition)，java的微型版本。

查看java 版本 命令行执行java -version 命令

由四方面组成： （1）Java编程语言 （2）Java类文件格式 （3）Java虚拟机 （4）Java应用程序接口 [21]
当编辑并运行一个Java程序时，需要同时涉及到这四种方面。使用文字编辑软件（例如记事本、写字板、UltraEdit等）或集成开发环境（Eclipse、MyEclipse等）在Java源文件中定义不同的类 [22]  ，通过调用类（这些类实现了Java API）中的方法来访问资源系统，把源文件编译生成一种二进制中间码，存储在class文件中，然后再通过运行与操作系统平台环境相对应的Java虚拟机来运行class文件，执行编译产生的字节码，调用class文件中实现的方法来满足程序的Java API调用 [6]  。
我们知道，传统的Java Web应用程序是采用JSP+Servlet+Javabean来实现的，这种模式实现了最基本的MVC分层，使的程序结构分为几层，有负责前台展示的JSP、负责流程逻辑控制的Servlet以及负责数据封装的Javabean。但是这种结构仍然存在问题：如JSP页面中需要使用符号嵌入很多的Java代码，造成页面结构混乱，Servlet和Javabean负责了大量的跳转和运算工作，耦合紧密，程序复用度低等等。
现在的结构是，Struts负责显示层，Hibernate负责持久层，Spring负责中间的业务层，这个结构是目前国内最流行的Java Web应用程序架构了。
*EJB ：EJB的全称是Enterprise JavaBeans，是Java中的商业应用组件技术。
◆Tomcat：轻量的JavaWeb容器，和WebLogic功能类似，使用简单、方便、免费、开源，但不支持EJB

◆JBoss：类似于Tomcat，功能更强，支持EJB

main 是一个程序的入口，一个 java 程序运行必须而且有且仅有一个 main 方法。
封装是一种信息隐蔽技术，它体现于类的说明，是对象的重要特性
[一个完整的Java。源程序应该包括下列部分：

  package语句，该部分至多只有一句，必须放在源程序的第一句。
  import语句，该部分可以有若干import语句或者没有，必须放在所有的类定义之前。
  public classDefinition，公共类定义部分，至多只有一个公共类的定义，Java语言规定该Java源程序的文件名必须与该公共类名完全一致。
  classDefinition，类定义部分，可以有0个或者多个类定义。
 interfaceDefinition，接口定义部分，可以有0个或者多个接口定义。]

 被继承的类称为超类（super class），派生类称为子类（subclass）。

 每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。

 在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法(Puppy myPuppy = new Puppy( "tommy" );)。

 [源文件.java 声明规则:一个源文件中只能有一个public类
 一个源文件可以有多个非public类
 源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。]

  super(); // 调用父类构造方法（1）
内部类：将一个类的定义放在另一个类的定义内部，这就是内部类。
成员变量也就是属性，在类中声明的。

局部变量，在方法中声明或代码块中声明。
2.初始值不同

成员变量如果没有赋值则是有默认值的，数据类型不同则默认值不同。

局部变量是没有默认值，也就是说必须先声明，再赋值，最后才使用。
成员变量随着对象的创建而存在，随着对象的回收而释放。

静态变量随着类的加载而存在，随着类的消失而消失。

成员变量只能被对象调用。

静态变量可以被对象调用，还可以被类名调用。

char类型是一个单一的 16 位 Unicode 字符；
在 Java 中使用 final 关键字来修饰常量

java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析
只有 boolean 不参与数据类型的转换
final 表示"最后的、最终的"含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。
synchronized 关键字声明的方法同一时间只能被一个线程访问。
volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。
当对象被序列化时（写入字节序列到目标文件）时，transient阻止实例中那些用此关键字声明的变量持久化(序列化)；
*变量持久化
子类是父类的类型，但父类不是子类的类型。

子类的实例可以声明为父类型，但父类的实例不能声明为子类型。
if...else if...else 语句
简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。

在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java 语言为每一个内置数据类型提供了对应的包装类,所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。
如果要操作少量的数据用 String ；
单线程操作大量数据用StringBuilder ；
多线程操作大量数据，用StringBuffer。
常用的是使用'+'操作符来连接字符串
*线程安全的（不能同步访问）
String 长度大小不可变

StringBuffer 和 StringBuilder 长度可变

StringBuffer 线程安全 StringBuilder 线程不安全

StringBuilder 速度快
*Java StringBuffer 和 StringBuilder 类
数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。

Java 语言中提供的数组是用来存储固定大小的同类型元素
你还可以使用如下的方式创建数组： dataType[] arrayRefVar = {value0, value1, ..., valuek};
java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。
声明二维数组：有两行，列数待定，数组结构 = { { }, { } }
java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。
Calendar类实现了公历日历，GregorianCalendar类是Calendar类的一个具体实现。
Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。
Java 休眠(sleep)
Java 的正则表达式中，两个 \\ 代表其他语言中的一个 \

Matcher 类也提供了appendReplacement 和 appendTail 方法用于文本替换

java.util.regex 包主要包括以下三个类：Pattern 类-Matcher 类-PatternSyntaxException
*关于小括号分组/捕获组
[一般情况下，定义一个方法包含以下语法：

修饰符 返回值类型 方法名(参数类型 参数名){
    ...
    方法体
    ...
    return 返回值;
}]
Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。
一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。

Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。
*java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。
*输入的时候字符都是可见的，所以Scanner类不适合从控制台读取密码。从Java SE 6开始特别引入了Console类来实现这个目的。
异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。
throws 用在函数上，声明该函数的功能可能会出现问题。
Java 不支持多继承，但支持多重继承。
super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。

this关键字：指向自己的引用。
java文件被编译成class文件时，在子类的所有构造函数中的第一行（第一个语句）会默认自动添加 super() 语句，在执行子类的构造函数前，总是会先执行父类中的构造函数。
子类的所有构造方法内部， 第一行会（隐式）自动先调用父类的无参构造函数super()；
Java 转型问题其实并不复杂，只要记住一句话：父类引用指向子类对象。 什么叫父类引用指向子类对象，且听我慢慢道来。 从 2 个名词开始说起：向上转型(upcasting) 、向下转型(downcasting)。

多态是同一个行为具有多个不同表现形式或形态的能力。
*虚拟方法调用
对于多态，可以总结以下几点：

一、使用父类类型的引用指向子类的对象；

二、该引用只能调用父类中定义的方法和变量；

三、如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）;
——————————————————————
在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。
在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。
3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。

4. 构造方法，类方法（用static修饰的方法）不能声明为抽象方法。

没有任何方法的接口被称为标记接口。
在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。
使用标记接口的唯一目的是使得可以用 instanceof 进行类型查询，例如： if(obj instanceof Cloneable) {………}
实现抽象类和接口的类必须实现其中的所有方法。抽象类中可以有非抽象方法。接口中则不能有实现方法。
接口中定义的变量默认是 public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。
abstract class 和 interface 是 Java 语言中的两种定义抽象类的方式，它们之间有很大的相似性。
接口文件保存在 .java 结尾的文件中，文件名使用接口名。
*系统变量 （设置 CLASSPATH 系统变量）
如果设置PATH变量是为了让操作系统找到指定的工具程序，那么设置CLASSPATH变量的目的就是让Java执行环境找到指定的Java程序对应的class文件以及程序中引用的其他class文件。
设置CLASSPATH的目的在于通知Java执行环境在哪些目录下可以找到所耍执行的JaVa程序。


一般在安装JDK后，需要设置PATH和CLASSPATH环境变量。如果不设置会对以后使用造成一定的影响。
javac 的 -d参数用于指定生成class文件的位置，.(点号)表示当前目录。
一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。
包声明应该在源文件的第一行
包名必须与相应的字节码所在的目录结构相吻合。
*数据结构
*对象序列化
*守护线程
*导入包
Java 8 (又称为 jdk 1.8)
socket通过使用 I/O 流在进行通信，每一个socket都有一个输出流和一个输入流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。
在Java中的数据结构主要包括以下几种接口和类： 枚举（Enumeration） 位集合（BitSet） 向量（Vector） 栈（Stack） 字典（Dictionary） 哈希表（Hashtable） 属性（Properties）
Enumeration接口中定义了一些方法，通过这些方法可以枚举（一次获得一个）对象集合中的元素，这种传统接口已被迭代器取代，尽管如此，它还是使用在诸如Vector和Properties这些传统类所定义的方法中，除此之外，还用在一些API类，并且在应用程序中也广泛被使用。
早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack, 和 Properties 这些类用来存储和操作对象组。 虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同，产生集合框架
集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList, HashSet, 和 TreeSet 等,除此之外你也可以通过这些接口实现自己的集合。
集合框架是一个用来代表和操纵集合的统一架构，有接口，实现类，算法构成
一般遍历数组都是采用for循环或者增强for，这两个方法也可以用在集合框架，但是还有一种方法是采用迭代器遍历集合框架，它是一个对象，实现了Iterator 接口或ListIterator接口。
采用迭代器的方法，该方法可以不用担心在遍历的过程中会超出集合的长度。
集合框架的类和接口均在java.util包中。
任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换。
对于泛型，只是允许程序员在编译时检测到非法的类型而已。/泛型方法/泛型类
 当序列化一个对象到文件时， 按照 Java 的标准约定是给文件一个 .ser 扩展名。
 关于序列化，常又称为持久化，将其写入磁盘中。
 如果你想知道一个 Java 标准类是否是可序列化的，请查看该类的文档。检验一个类的实例是否能序列化十分简单， 只需要查看该类有没有实现 java.io.Serializable接口。
 java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。
 AIO编程：Asynchronous IO： 异步非阻塞的编程方式。
 多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。
 *创建线程
*socket调用InetAddress 类的方法
*socket调用InetAddress类中方法
进程-应用程序的执行实例，有独立的内存空间和系统资源
线程池，其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。
线程池都是通过线程池工厂创建，再调用线程池中的方法获取线程，再通过线程去执行任务方法。
每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。

Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。

默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。
使用 JDBC 连接 MySQL 数据库。
DAO (DataAccessobjects 数据存取对象)是指位于业务逻辑和持久化数据之间实现对持久化数据的访问。通俗来讲，就是将数据库操作都封装起来。

对外提供相应的接口

在面向对象设计过程中，有一些"套路”用于解决特定问题称为模式。

【一个典型的DAO 模式主要由以下几部分组成。
 
  1、DAO接口： 把对数据库的所有操作定义成抽象方法，可以提供多种实现。
  2、DAO 实现类： 针对不同数据库给出DAO接口定义方法的具体实现。
  3、实体类：用于存放与传输对象数据。
  4、数据库连接和关闭工具类： 避免了数据库连接和关闭代码的重复使用，方便修改。】
————————————————

