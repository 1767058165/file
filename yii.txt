/jquery.pjax.js

/创建小部件/看分页组件


/CTreeView/上传图片框/Bower包管理器

/上一篇与下一篇/推荐设置

2.0 版框架是完全重写的，在 1.1 和 2.0 两个版本之间存在相当多差异。

Yii 非常易于扩展。你可以自定义或替换几乎任何一处核心代码。
Yii2的最新版本是 2.1.10，发布于 2016年10月20日。Yii 2.0 在 PHP 5.4.0 版本以上完全重写了Yii。它的目的是成为一个最先进的新一代的PHP开发框架。Yii2.0不兼容1.1。


intl Yii 2.0 使用 PHP 扩展 intl 来支持国际化的相关功能。

路径别名（Path Alias）
Yii 2.0 将路径别名的应用扩大至文件/目录路径和 URL。Yii 2.0 中路径别名必须以 @ 符号开头，以区别于普通文件目录路径或 URL。例如 @yii 就是指向 Yii 安装目录的别名。

除了使用 PHP 作为主要的模板语言，Yii 2.0 也装备了两种流行模板引擎的官方支持：Smarty 和 Twig。过去的 Prado 模板引擎不再被支持。要使用这些模板引擎，你需要配置 view 应用组件，给它设置 [[yii\base\View::$renderers|View::$renderers]] 属性。

Yii 2.0 使用 [[yii\base\Widget]] 作为小部件基类

一个资源包是一个目录下的资源文件集合（如 JavaScript 文件、CSS 文件、图片文件等）

Yii 2.0 引进了表单栏（field）的概念，用来创建一个基于 [[yii\widgets\ActiveForm]]的表单。一个表单栏是一个由标签、输入框、错误消息（可能还有提示文字）组成的容器，被表示为 [[yii\widgets\ActiveField|ActiveField]] 对象。


http 500有可能是程序错误
――――――――――――――――――――
你可以通过两种方式来安装Yii框架：

通过Composer
通过下载一个所需文件以及Yii框架文件的应用模板（需要cookieValidationKey 配置项添加一个密钥）
――――――――――――――――――――――――――
你可以创建 SQLite，MySQL，PostregSQL，MSSQL 或 Oracle 数据库，Yii 内置多种数据库支持。
一般来说，应用中的文件可被分为两类：在 basic/web 下的和在其它目录下的。

每个应用都有一个入口脚本 web/index.php，这是整个应用中唯一可以访问的 PHP 脚本。入口脚本接受一个 Web 请求并创建应用实例去处理它。 应用在它的组建辅助下解析请求，并分派请求至 MVC 元素。视图使用小部件去创建复杂和动态的用户界面。

――――――――――――――――――
动作是最终用户可以直接访问并执行的对象。动作被组织在控制器中。一个动作的执行结果就是最终用户收到的响应内容。

――――――――――
Yii 使用action前缀区分普通方法和动作。action前缀后面的名称被映射为动作的 ID，控制器 ID和动作 ID使用同样的命名规则。

――――――――――――――
通常在控制器创建动作
――――――――――】
http://hostname/index.php?r=site/say&message=Hello+World：

上面 URL 中的参数r需要更多解释。它代表路由，是整个应用级的，指向特定动作的独立 ID。路由格式是 控制器 ID/动作 ID。应用接受请求的时候会检查参数，使用控制器 ID 去确定哪个控制器应该被用来处理请求。然后相应控制器将使用动作 ID 去确定哪个动作方法将被用来做具体工作。上述例子中，路由site/say将被解析至SiteController控制器和其中的say动作。因此SiteController::actionSay()方法将被调用处理请求。

――――――――――――――――――――――――――――――――――
动作通过render()方法进行视图渲染输出
――――――――――――――――――
#!/usr/bin/env php

npm导入包使用
――――――――――――――――――――――
表达式 Yii::$app 代表应用实例，它是一个全局可访问的单例。同时它也是一个服务定位器，能提供request，response，db 等等特定功能的组件。

――――――――――――――――――
活动记录是面向对象、功能强大的访问和动作数据库数据的方式。你可以在活动记录章节了解更多信息。除此之外你还可以使用另一种更原生的称做数据访问对象的方法动作数据库数据
――――――――――――――――――――――
分页的OFFSET，用于定义起始获取位置

――）――
控制器命名-大小写规则
――――――――――――――
为了使用数据库，你将会配置一个数据库连接，创建一个活动记录类，并且创建一个动作及一个视图。

――――――――――――――――――――
使用 Gii 去自动生成 Web 站点常用功能的代码。使用 Gii 生成代码非常简单，只要按照 Gii 页面上的介绍输入正确的信息即可。

――――――――――
yii 应用遵循 模型-视图-控制器（model-view-controller (MVC)）设计模式。

――――――――――――――――――――――――――――
Applications are objects that govern the overall structure and lifecycle of Yii application systems. Each Yii application system contains a single application object which is created in the entry script and is globally accessible through the expression----- \Yii::$app.

______――――――――――――――――――――――
控制台应用的入口脚本文件命名：#!/usr/bin/env php
――――――――――――――――――
Yii有两种应用主体: yii\web\Application and yii\console\Application， 如名称所示，前者主要处理网页请求，后者处理控制台请求。
――――――――――――――――――
应用主体是管理 Yii 应用系统整体结构和生命周期的对象。 每个Yii应用系统只能包含一个应用主体， 应用主体在 入口脚本 中创建并能通过表达式 \Yii::$app 全局范围内访问

――――――――――――――――――――――――――
在一个应用中，至少要配置2个属性: yii\base\Application::id 和 yii\base\Application::basePath。

注意 模块 和 控制器 都会触发 beforeAction 事件。
_____________――――――――――――――――――――――
操作ID应仅包含英文小写字母、数字、下划线和中横杠，操作ID中的中横杠用来分隔单词。

――――――――――――――――――――――――――
操作方法的名字是根据操作ID遵循如下规则衍生：

将每个单词的第一个字母转为大写;
去掉中横杠;
增加action前缀.

――――――――――
捕获所有请求
有时使用一个简单的控制器动作处理所有请求是有用的。如，当网站维护时显示一条布告。动态或通过应用配置文件配置 web 应用的 catchAll 属性可以实现该目的：

return [
    'id' => 'basic',
    'basePath' => dirname(__DIR__),
    // ...
    'catchAll' => [ // <-- 这里配置
        'offline/notice',
        'param1' => 'value1',
        'param2' => 'value2',
    ],
]
上面 offline/notice 指向 OfflineController::actionNotice() 。 param1 和 param2 是传递给动作方法的参数。

控制器操作--内联操作、独立操作（即独立操作类--如果动作非常通用，最好用单独的类实现以便重用。）
――――――――――――――――――――
因为多场景的使用通常发生在Active Record 类中.

通过覆盖 yii\base\Model::rules() 方法指定 模型属性应该满足的规则来申明模型相关验证规则

默认情况下，模型支持的场景由模型中申明的 验证规则 来决定， 但你可以通过覆盖yii\base\Model::scenarios()方法来自定义行为

model 类也是更多高级模型如Active Record 活动记录的基类

模型并不强制一定要继承yii\base\Model，但是由于很多组件支持yii\base\Model， 最好使用它做为模型基类。

默认情况下，属性标签通过yii\base\Model::generateAttributeLabel()方法自动从属性名生成. 它会自动将驼峰式大小写变量名转换为多个首字母大写的单词


可调用 yii\base\Model::validate() 来验证接收到的数据， 该方法使用yii\base\Model::rules()申明的验证规则来验证每个相关属性， 如果没有找到错误，会返回 true， 否则它会将错误保存在 yii\base\Model::errors 属性中并返回false.

通过覆盖 yii\base\Model::rules() 方法指定 模型属性应该满足的规则来申明模型相关验证规则。

有时你想一条规则只在某个 场景 下应用， 为此你可以指定规则的 on 属性

【块赋值只用一行代码将用户所有输入填充到一个模型，非常方便， 它直接将输入数据对应填充到 yii\base\Model::attributes 属性。

$model = new \app\models\ContactForm;
$model->attributes = \Yii::$app->request->post('ContactForm');】
――――――――――――――――――――――――――――――
安全属性和不安全属性

数据导出

模型通常要导出成不同格式，例如，你可能想将模型的一个集合转成JSON或Excel格式， 导出过程可分解为两个步骤， 第一步，模型转换成数组；第二步，数组转换成所需要的格式。 你只需要关注第一步，因为第二步可被通用的 数据转换器如yii\web\JsonResponseFormatter来完成。

――――――――――――――――――――
将模型转换为数组最简单的方式是使用 yii\base\Model::attributes 属性，更灵活和强大的将模型转换为数组的方式是使用 yii\base\Model::toArray() 方法

――――――――――
应用组件概念

应用主体是服务定位器， 它部署一组提供各种不同功能的 应用组件 来处理请求。 例如，urlManager组件负责处理网页请求路由到对应的控制器。 db组件提供数据库相关服务等等
――――――――――――――――――――――――
应用组件可以是任意对象，可以在 应用主体配置配置 yii\base\Application::components 属性 。

――――――――――――――――――――――
预定义的核心应用组件列表，可以和普通应用组件一样配置和自定义它们

应用事件

应用在处理请求过程中会触发事件， 可以在配置文件配置事件处理代码
――――――――――――――
模型是代表业务数据、规则和逻辑的中心地方，通常在很多地方重用， 在一个设计良好的应用中， 模型通常比控制器代码多。

――――――――――――――――――――
视图有其他预定义变量如 $model

在 控制器 中，可调用以下控制器方法来渲染视图：

yii\base\Controller::render(): 渲染一个 视图名 并使用一个 布局 返回到渲染结果。
yii\base\Controller::renderPartial(): 渲染一个 视图名 并且不使用布局。
等方法。
――――――――――――――――――――――――――
在 小部件 中，可调用以下小部件方法来渲染视图：

yii\base\Widget::render(): 渲染一个 视图名.
yii\base\Widget::renderFile(): 渲染一个视图文件目录或 别名下的视图文件。

@app?

视图名以双斜杠 // 开头，对应的视图文件路径为 @app/views/ViewName， 也就是说视图文件在 yii\base\Application::viewPath 路径下找， 例如 //site/about 对应到 @app/views/site/about.php。

可以在视图中渲染另一个视图

在视图中，可访问 $this 指向 yii\web\View 来管理和渲染这个视图文件

有时候你想嵌套一个布局到另一个
――――――――――――――――――――――――――――――――――――――――
视图组件提供如下实用的视图相关特性，每项详情会在独立章节中介绍：

主题: 允许为你的Web站点开发和修改主题；
片段缓存: 允许你在Web页面中缓存片段；
客户脚本处理: 支持CSS 和 JavaScript 注册和渲染；
资源包处理: 支持 资源包的注册和渲染；
模板引擎: 允许你使用其他模板引擎，如 Twig, Smarty。

――――――――――――――――――
视图文件默认使用main布局文件

内容视图定义的标题会覆盖布局视图标题
――――――――――
框架基类文件路径--ventor-yiisoft-yii2
――――――――――――――――――――――――
如果想在内容视图中生成元标签，可在内容视图中调用yii\web\View::registerMetaTag()方法

注册链接标签link---调用yii\web\View::registerLinkTag()
__________――――――――――――――――――――――
模块是独立的软件单元，由模型, 视图, 控制器和其他支持组件组成， 终端用户可以访问在应用主体中已安装的模块的控制器， 模块被当成小应用主体来看待，和应用主体不同的是， 模块不能单独部署，必须属于某个应用主体。

――――――――――――――――――――――
使用模块---模块对应有相应属性

要在应用中使用模块，只需要将模块加入到应用主体配置的yii\base\Application::modules属性的列表中

过滤器本质上是一类特殊的 行为，所以使用过滤器和 使用 行为一样。 可以在控制器类中覆盖它的 yii\base\Controller::behaviors() 方法来申明过滤器
――――――――――――――――――――――――

――――――――――――――――――――――――――――――
小部件是面向对象方式来重用视图代码。

――――――――――――――――――――
创建小部件---需继承 yii\base\Widget 类并覆盖 yii\base\Widget::init() 和/或 yii\base\Widget::run() 方法可创建小部件。通常init() 方法处理小部件属性， run() 方法包含小部件生成渲染结果的代码。 

当一个小部件只包含视图代码，它和视图很相似， 实际上，在这种情况下，唯一的区别是小部件是可以重用类， 视图只是应用中使用的普通PHP脚本。
――――――――――――――――――――
Yii中的资源是和Web页面相关的文件，可为CSS文件，JavaScript文件，图片或视频等， 资源放在Web可访问的目录下，直接被Web服务器调用。

――――――――――――――――――
几乎每个 Yii 框架的核心类都继承自 yii\base\Object 或其子类。 这意味着只要在核心类中见到 getter 或 setter 方法，就可以像调用属性一样调用它。

getter 方法是名称以 get 开头的方法，而 setter 方法名以 set 开头。

附加事件处理器

调用 yii\base\Component::on() 方法来附加处理器到事件上。
移除事件的全部处理器，简单调用 yii\base\Component::off() 即可

事件通过调用 yii\base\Component::trigger() 方法触发

推荐使用类常量来表示事件名。上例中，常量 EVENT_HELLO 用来表示 hello 

事件可以将自定义代码“注入”到现有代码中的特定执行点。附加自定义代码到某个事件，当这个事件被触发时，这些代码就会自动执行。

――――――――――――
资源包指定为继承yii\web\AssetBundle的PHP类， 包名为可自动加载的PHP类名， 在资源包类中，要指定资源所在位置， 包含哪些CSS和JavaScript文件以及和其他包的依赖关系。
――――――――――――――
Yii在资源包中管理资源，资源包简单的说就是放在一个目录下的资源集合， 当在视图中注册一个资源包， 在渲染Web页面时会包含包中的CSS和JavaScript文件。
――――――――――――――――――――――――――――
绝对URL地址表示为外部JavaScript文件，如 http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js 或 //ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js.

――――
，如果资源包放在Web不能访问的目录， 当视图注册资源时资源会被拷贝到一个Web可访问的目录中， 这个过程称为资源发布，yii\web\AssetManager会自动处理该过程。



除了拷贝文件方式发布资源，如果操作系统和Web服务器允许可以使用符号链接，该功能可以通过设置 yii\web\AssetManager::linkAssets 为 true 来启用。

符号链接？

资源转换--当在视图中注册一个这样的资源包，yii\web\AssetManager资源管理器会自动运行预处理工具将使用扩展语法 的资源转换成CSS/JavaScript，当视图最终渲染页面时， 在页面中包含的是CSS/Javascipt文件， 而不是原始的扩展语法代码文件。
――――――――――――――――――――――――
Yii默认使用Closure Compiler来合并JavaScript文件， 使用YUI Compressor来合并CSS文件， 你应手工安装这些工具或修改选项使用你喜欢的工具。

扩展是专门设计的在 Yii 应用中随时可拿来使用的， 并可重发布的软件包。例如， yiisoft/yii2-debug 扩展在你的应用的每个页面底部添加一个方便用于调试的工具栏， 帮助你简单地抓取页面生成的情况。 你可以使用扩展来加速你的开发过程。

如果扩展为终端用户显示信息，这些信息应该用 Yii::t() 包装起来，以便可以进行翻译。

――――――――――――
一些大型应用都包含有非常复杂的应用配置， 它们会被分割到许多更小的配置文件中。

因为响应格式默认为yii\web\Response::FORMAT_HTML, 只需要在操作方法中返回一个字符串， 如果想使用其他响应格式，应在返回数据前先设置格式

――――――――――――――――――――――
一些浏览器提供特殊的名为X-Sendfile的文件发送功能， 原理为将请求跳转到服务器上的文件， Web应用可在服务器发送文件前结束，为使用该功能， 可调用yii\web\Response::xSendFile()

――――――――――――
当应用完成处理一个请求后, 会生成一个yii\web\Response响应对象并发送给终端用户 响应对象包含的信息有HTTP状态码，HTTP头和主体内容等, 网页应用开发的最终目的本质上就是根据不同的请求构建这些响应对象。

可在 response 组件中操控yii\web\Response::headers来发送HTTP头部信息， 例如：

$headers = Yii::$app->response->headers;

――――――――――――――――――――――――
如果已有格式化好的主体字符串，可赋值到响应的yii\web\Response::content属性， 例如：

Yii::$app->response->content = 'hello world!';
――――――――――――――――――
如果在发送给终端用户之前需要格式化，应设置 yii\web\Response::format 和 yii\web\Response::data 属性，yii\web\Response::format 属性指定yii\web\Response::data中数据格式化后的样式，例如：

$response = Yii::$app->response;
$response->format = \yii\web\Response::FORMAT_JSON;
$response->data = ['message' => 'hello world'];

――――――――――――――――――――――
为更好的性能和可读性，推荐// 使用带通用前缀的键来存储数组
$session['captcha.number'] = 5;
$session['captcha.lifetime'] = 3600;

Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库

ＳＥＳＳＩＯＮID长度---注意: 根据php.ini 设置的 session.hash_function，你需要调整id列的长度， 例如，如果 session.hash_function=sha256 ， 应使用长度为64而不是40的char类型
――――――――――――――――――――――――
Flash 数据

Flash数据是一种特别的session数据，它一旦在某个请求中设置后， 只会在下次请求中有效，然后该数据就会自动被删除。 常用于实现只需显示给终端用户一次的信息， 如用户提交一个表单后显示确认信息。
――――――――――――――
使用方法：
$session = Yii::$app->session;

// 请求 #1
// 设置一个名为"postDeleted" flash 信息
$session->setFlash('postDeleted', 'You have successfully deleted your post.');

// 请求 #2
// 显示名为"postDeleted" flash 信息
echo $session->getFlash('postDeleted');

// 请求 #3
// $result 为 false，因为flash信息已被自动删除
$result = $session->hasFlash('postDeleted');
――――――――――――――――――

Yii将session和cookie封装成对象并增加一些功能， 可通过面向对象方式访问它们。

Yii使用 yii\web\Cookie对象来代表每个cookie，yii\web\Request 和 yii\web\Response 通过名为'cookies'的属性维护一个cookie集合， 前者的cookie 集合代表请求提交的cookies， 后者的cookie集合表示发送给用户的cookies。

――――――――――――――――
Cookie验证

在上两节中，当通过request 和 response 组件读取和发送cookie时， 你会喜欢扩展的cookie验证的保障安全功能，它能 使cookie不被客户端修改。该功能通过给每个cookie签发一个 哈希字符串来告知服务端cookie是否在客户端被修改， 如果被修改，通过request组件的yii\web\Request::cookiescookie集合访问不到该cookie。



事件处理器是一个PHP 回调函数，当它所附加到的事件被触发时它就会执行。可以使用以下回调函数之一：

字符串形式指定的 PHP 全局函数，如 'trim' ；
对象名和方法名数组形式指定的对象方法，如 [$object, $method] ；
类名和方法名数组形式指定的静态类方法，如 [$class, $method] ；
匿名函数，如 function ($event) { ... } 。

事件

。 行为，也称为 mixins



刷新缓存--ob_implicit_flush()将打开或关闭绝对（隐式）刷送。绝对（隐式）刷送将导致在每次输出调用后有一次刷送操作，以便不再需要对 flush() 的显式调用。
――――――――
别名用来表示文件路径和 URL，这样就避免了在代码中硬编码一些绝对路径 和 URL。
Yii 预定义了大量可用的别名。

我们把通过 Yii::setAlias() 定义的别名称为根别名，而用他们衍生出去的别名成为衍生别名。
――――――――――――――――――
你可以调用 Yii::getAlias() 命令来解析根别名到对应的文件路径或 URL。

别名在 Yii 的很多地方都会被正确识别，无需调用 Yii::getAlias() 来把它们转换为路径/URL。

$aliases定义在BaseYii.php里面
――――――――――――――――――――――――――
当你同时使用其他自动加载器和 Yii 自动加载器时，应该在其他自动加载器安装成功之后，再包含 Yii.php 文件。

你也可以只使用 Composer 的自动加载，而不用 Yii 的自动加载。 不过这样做的话，类的加载效率会下降，且你必须遵循 Composer 所设定的规则， 从而让你的类满足可以被自动加载的要求。


在你不使用 Yii 的自动加载器时，Composer 的自动加载器仍然可以帮你自动加载扩展内的类。

t()方法？

开发环境--3个,开启生产环境

【开发环境和生产环境的设置


入口设置：
在web/index.PHP中：


测试环境：
[html] view plain copy print?
defined('YII_DEBUG') or define('YII_DEBUG', true);  
defined('YII_ENV') or define('YII_ENV', 'dev');  

生产环境：
[html] view plain copy print?
//defined('YII_DEBUG') or define('YII_DEBUG', true);  
defined('YII_ENV') or define('YII_ENV', 'prod');  】

初始化，主文件加载总的配置文件web.php返回$config配置变量，配置应用并注册组件。

――――――――――――――――――――――――――――
服务定位器

服务定位器是一个了解如何提供各种应用所需的服务（或组件）的对象。 在服务定位器中，每个组件都只有一个单独的实例，并通过ID 唯一地标识。 用这个 ID 就能从服务定位器中得到这个组件。

【在 Yii 中，服务定位器是 yii\di\ServiceLocator 或其子类的一个实例。

最常用的服务定位器是application（应用）对象，可以通过 \Yii::$app 访问。 它所提供的服务被称为application components（应用组件），比如
：request、response、urlManager 组件。 可以通过服务定位器所提供的功能，非常容易地配置这些组件， 或甚至是用你自己的实现替换掉他们。

最常用的服务定位器是application（应用）对象，可以通过 \Yii::$app 访问。 它所提供的服务被称为application components（应用组件），比如：request、response、urlManager 组件。 可以通过服务定位器所提供的功能，非常容易地配置这些组件， 或甚至是用你自己的实现替换掉他们。

除了 application 对象，每个模块对象本身也是一个服务定位器。application.php继承自module.php.】
――――――――――――――――――。

【要使用服务定位器，第一步是要注册相关组件有3种方式。 组件可以通过 yii\di\ServiceLocator::set() 方法进行注册。

例如
1、// 用组件注册 "pageCache" 组件
$locator->set('Cache', new FileCache);
一旦组件被注册成功，你可以任选以下两种方式之一，通过它的 ID 访问它：
$cache = $locator->get('cache');
// 或者
$cache = $locator->cache;】

――――――――――――――――――
2、// 通过一个可用于创建该组件的配置数组，注册 "db" （数据库）组件。
$locator->set('db', [
    'class' => 'yii\db\Connection',
    'dsn' => 'mysql:host=localhost;dbname=demo',
    'username' => 'root',
    'password' => '',
]);
 /3、// 通过一个能返回该组件的匿名函数，注册 "search" 组件。
$locator->set('search', function () {
    return new app\components\SolrService;
});

服务定位器注册多个组件--yii\di\ServiceLocator::setComponents(array)
――――――――――――――――――――――――――――――――
当你第一次访问某组件时， yii\di\ServiceLocator 会通过该组件的注册信息创建一个该组件的实例，并返回它。 之后，如果再次访问，则服务定位器会返回同一个实例。
――――――――――――
依赖注入（Dependency Injection，DI）容器就是一个对象，它知道怎样初始化并配置对象及其依赖的所有对象。

依赖注入和服务定位器都是流行的设计模式，它们使你可以用充分解耦且更利于测试的风格构建软件。

什么时候注册依赖关系

由于依赖关系在创建新对象时需要解决，因此它们的注册应该尽早完成。如下是推荐的实践：

如果你是一个应用程序的
开发者，你可以在应用程序的入口脚本或者被入口脚本引入的脚本中注册依赖关系。
如果你是一个可再分发扩展的开发者，你可以将依赖关系注册到扩展的引导类中。

Yii 通过 yii\di\Container 类提供 DI 容器特性。它支持如下几种类型的依赖注入：

构造方法注入;
Setter 和属性注入;
PHP 回调注入.

yii 包含了一个建立在 PHP PDO 之上的数据访问层 (DAO)。DAO为不同的数据库提供了一套统一的API。 其中`ActiveRecord` 提供了数据库与模型(MVC 中的 M,Model) 的交互，`QueryBuilder` 用于创建动态的查询语句。

数据库4中隔离级别

数据执行后定义事件---'db' => [
    // ...
    'on afterOpen' => function($event) {
        // $event->sender refers to the DB connection
        $event->sender->createCommand("SET time_zone = 'UTC'")->execute();
    }
],


Yii::$app->db->createCommand('UPDATE post SET status=1 WHERE id=1')
   ->execute();
execute()执行不返回数据，其他返回数据

Yii::$app->db->transaction(function ($db) {
    // outer transaction
    
    $db->transaction(function ($db) {
        // inner transaction
    });
});

查询构建器建立在 Dao基础之上，可让你创建 程序化的、DBMS无关的SQL语句。相比于原生的SQL语句，查询构建器可以帮你 写出可读性更强的SQL相关的代码，并生成安全性更强的SQL语句。

使用查询构建器通常包含以下两个步骤：

创建一个 yii\db\Query 对象来代表一条 SELECT SQL 语句的不同子句（例如 SELECT, FROM）。
执行 yii\db\Query 的一个查询方法（例如：all()）从数据库当中检索数据。


yii\db\Query::select() 方法用来指定 SQL 语句当中的 SELECT 子句。 你可以像下面的例子一样使用一个数组或者字符串来定义需要查询的字段。当 SQL 语句 是由查询对象生成的时候，被查询的字段名称将会自动的被引号括起来。

$query->select(['id', 'email']);

// 等同于：

$query->select('id, email');

你应该调用 yii\db\Query::distinct() 方法来去除重复行，如下所示：

// SELECT DISTINCT `user_id` ...
$query->select('user_id')->distinct();

你可以通过字符串或者数组的形式来定义被查询的表名称。就像你写原生的 SQL 语句一样， 表名称里面可包含数据库前缀，以及/或者表别名。例如：

$query->from(['public.user u', 'public.post p']);

// 等同于：

$query->from('public.user u, public.post p');
如果你使用的是数组的格式，那么你同样可以用数组的键值来定义表别名，如下所示：

$query->from(['u' => 'public.user', 'p' => 'public.post']);


yii\db\Query::where() 方法定义了 SQL 语句当中的 WHERE 子句。 你可以使用如下三种格式来定义 WHERE 条件：

字符串格式，例如：'status=1'
哈希格式，例如： ['status' => 1, 'type' => 2]
操作符格式，例如：['like', 'name', 'test']

操作符格式

操作符格式允许你指定类程序风格的任意条件语句，如下所示：

[操作符, 操作数1, 操作数2, ...]


你可以使用 yii\db\Query::andWhere() 或者 yii\db\Query::orWhere() 在原有条件的基础上 附加额外的条件。你可以多次调用这些方法来分别追加不同的条件。 例如，

$status = 10;
$search = 'yii';

$query->where(['status' => $status]);

if (!empty($search)) {
    $query->andWhere(['like', 'title', $search]);
}


当 WHERE 条件来自于用户的输入时，你通常需要忽略用户输入的空值。 例如，在一个可以通过用户名或者邮箱搜索的表单当中，用户名或者邮箱 输入框没有输入任何东西，这种情况下你想要忽略掉对应的搜索条件， 那么你就可以使用 yii\db\Query::filterWhere() 方法来实现这个目的：

// $username 和 $email 来自于用户的输入
$query->filterWhere([
    'username' => $username,
    'email' => $email,		
]);


yii\db\Query::filterWhere() 和 yii\db\Query::where() 唯一的不同就在于，前者 将忽略在条件当中的hash format的空值。所以如果 $email 为空而 $username 不为空，那么上面的代码最终将生产如下 SQL ...WHERE username=:username。



yii\db\Query::having() 方法是用来指定 SQL 语句当中的 HAVING 子句。它带有一个条件， 和 where() 中指定条件的方法一样。


你可以调用 yii\db\Query::andHaving() 或者 yii\db\Query::orHaving() 方法来为 HAVING 子句追加额外的条件

注意：yii\db\Query::one() 方法只返回查询结果当中的第一条数据， 条件语句中不会加上 LIMIT 1 条件。如果你清楚的知道查询将会只返回一行或几行数据 （例如， 如果你是通过某些主键来查询的），这很好也提倡这样做。但是，如果查询结果 有机会返回大量的数据时，那么你应该显示调用 limit(1) 方法，以改善性能。 例如， (new \yii\db\Query())->from('user')->limit(1)->one()。

――――――――――――――――――――――――――――
有时候，你也许想要测试或者使用一个由 yii\db\Query 对象创建的 SQL 语句。 你可以使用以下的代码来达到目的：

$command = (new \yii\db\Query())
    ->select(['id', 'email'])
    ->from('user')
    ->where(['last_name' => 'Smith'])
    ->limit(10)
    ->createCommand();
    
// 打印 SQL 语句
echo $command->sql;
// 打印被绑定的参数
print_r($command->params);

// 返回查询结果的所有行
$rows = $command->queryAll();
――――――――――――――――――――――――――――――――
索引查询结果

当你在调用 yii\db\Query::all() 方法时，它将返回一个以连续的整型数值为索引的数组。 而有时候你可能希望使用一个特定的字段或者表达式的值来作为索引结果集数组。那么你可以在调用 yii\db\Query::all() 之前使用 yii\db\Query::indexBy() 方法来达到这个目的。 例如，

// 返回 [100 => ['id' => 100, 'username' => '...', ...], 101 => [...], 103 => [...], ...]
$query = (new \yii\db\Query())
    ->from('user')
    ->limit(10)
    ->indexBy('id')
    ->all();


――――――――――――――――――――――――――
批处理查询

当需要处理大数据的时候，像 yii\db\Query::all() 这样的方法就不太合适了， 因为它们会把所有数据都读取到内存上。为了保持较低的内存需求， Yii 提供了一个 所谓的批处理查询的支持。批处理查询会利用数据游标 将数据以批为单位取出来。

――――――――――――――――――――――――
批处理查询的用法如下：

use yii\db\Query;

$query = (new Query())
    ->from('user')
    ->orderBy('id');

foreach ($query->batch() as $users) {
    // $users 是一个包含100条或小于100条用户表数据的数组
}

// or if you want to iterate the row one by one
foreach ($query->each() as $user) {
    // $user 指代的是用户表当中的其中一行数据
}
yii\db\Query::batch() 和 yii\db\Query::each() 方法将会返回一个实现了Iterator 接口 yii\db\BatchQueryResult 的对象，可以用在 foreach 结构当中使用。在第一次迭代取数据的时候， 数据库会执行一次 SQL 查询，然后在剩下的迭代中，将直接从结果集中批量获取数据。默认情况下， 一批的大小为 100，也就意味着一批获取的数据是 100 行。你可以通过给 batch() 或者 each() 方法的第一个参数传值来改变每批行数的大小。

――――――――――――――――――――――――
Active Record

Active Record （活动记录，以下简称AR）提供了一个面向对象的接口， 用以访问数据库中的数据。一个 AR 类关联一张数据表， 每个 AR 对象对应表中的一行，对象的属性（即 AR 的特性Attribute）映射到数据行的对应列。 一条活动记录（AR对象）对应数据表的一行，AR对象的属性则映射该行的相应列。 

――――――――――――――――
Additionally, Yii also supports using Active Record with the following NoSQL databases
――――――――――――――――――――
要想声明一个 AR 类，你需要扩展 yii\db\ActiveRecord 基类， 并实现 tableName 方法，返回与之相关联的的数据表的名称：

例如，假定 Customer AR 类关联着 customer 表， 且该类的 name 属性代表 customer 表的 name 列。 你可以写以下代码来哉 customer 表里插入一行新的记录:

$customer = new Customer();
$customer->name = 'Qiang';
$customer->save();  // 一行新数据插入 customer 表
――――――――――――――――――――――――
namespace app\models;

use yii\db\ActiveRecord;

class Customer extends ActiveRecord
{
    /**
     * @return string 返回该AR类关联的数据表名
     */
    public static function tableName()
    {
        return 'customer';
    }
}

――――――――――――――――
AR 提供了两种方法来构建 DB 查询并向 AR 实例里填充数据：

yii\db\ActiveRecord::find()


在 Yii 中使用表单的主要方式是通过 yii\widgets\ActiveForm。如果是基于 模型的表单应首选这种方式。此外，在 yii\helpers\Html中也有一些实用的 方法用于添加按钮和帮助文本。

在客户端上显示的表单，大多数情况下有一个相应的模型，用来验证其输入的服务器数据 (可在 输入验证 一节获取关于验证的细节)。 当创建基于模型的表单时，第一步是定义模型本身。该模式可以是一个基于活动记录的类， 表示数据库中的数据，也可以是一个基于通用模型的类（继承自 yii\base\Model ）， 来获取任意的输入数据，如登录表单。
yii\db\ActiveRecord::findBySql()
以上两个方法都会返回 yii\db\ActiveQuery 实例
――――――――――――――――――――
有两个快捷方法：findOne 和 findAll() 用来返回一个或者一组ActiveRecord实例。前者返回第一个匹配到的实例，后者返回所有。 例如：

// 返回 id 为 1 的客户
$customer = Customer::findOne(1);

――――――――――――――――――――
批量获取数据

在 Query Builder（查询构造器） 里，我们已经解释了当需要从数据库中查询大量数据时，你可以用 batch query（批量查询）来限制内存的占用。 你可能也想在 AR 里使用相同的技巧，比如这样……

// 一次提取 10 个客户信息
foreach (Customer::find()->batch(10) as $customers) {
    // $customers 是 10 个或更少的客户对象的数组
}

――――――――――――――――――――――――――
下面的这些例子里，详细展现了如何使用这些方法：

// 插入新客户的记录
$customer = new Customer();
$customer->name = 'James';
$customer->email = 'james@example.com';
$customer->save();  // 等同于 $customer->insert();

// 更新现有客户记录
$customer = Customer::findOne($id);
$customer->email = 'james@example.com';
$customer->save();  // 等同于 $customer->update();

// 删除已有客户记录
$customer = Customer::findOne($id);
$customer->delete();

// 删除多个年龄大于20，性别为男（Male）的客户记录
Customer::deleteAll('age > :age AND gender = :gender', [':age' => 20, ':gender' => 'M']);

// 所有客户的age（年龄）字段加1：
Customer::updateAllCounters(['age' => 1]);
――――――――――――――――――――
数据输入与有效性验证

由于AR继承自yii\base\Model，所以它同样也支持Model的数据输入、验证等特性。
――――――――――――――――――――――――――――――――――――――――
class Order extends \yii\db\ActiveRecord
{
    // 订单和客户通过 Customer.id -> customer_id 关联建立一对一关系
    public function getCustomer()
    {
        return $this->hasOne(Customer::className(), ['id' => 'customer_id']);
    }
}
――――――――――――――――――――――――
中间关联表

有时，两个表通过中间表关联，定义这样的关联关系， 可以通过调用 yii\db\ActiveQuery::via() 方法或 yii\db\ActiveQuery::viaTable() 方法来定制 yii\db\ActiveQuery 对象 。

举例而言，如果 order 表和 item 表通过中间表 order_item 关联起来， 可以在 Order 类声明 items 关联关系取代中间表：

class Order extends \yii\db\ActiveRecord
{
    public function getItems()
    {
        return $this->hasMany(Item::className(), ['id' => 'item_id'])
            ->viaTable('order_item', ['order_id' => 'id']);
    }
}
――――――――――――――――――――――
 注意:当用即时加载定制 select() 时，确保连接 到关联模型的列都被包括了，否则，关联模型不会载入。如：

$orders = Order::find()->select(['id', 'amount'])->with('customer')->all();
// $orders[0]->customer 总是空的，使用以下代码解决这个问题：
$orders = Order::find()->select(['id', 'amount', 'customer_id'])->with('customer')->all();
――――――――――――――――――――――――

Customer::className()？利用object.php里面的object对象的className()静态方法，返回类名

――――――――――――――――――――――
调用 yii\db\ActiveQuery::with() 方法使用即时加载解决

延迟加载和即时加载（又称惰性加载与贪婪加载）
――――――――――――――――――――――――――
如前所述，当你第一次连接关联对象时， AR 将执行一个数据库查询 来检索请求数据并填充到关联对象的相应属性。 如果再次连接相同的关联对象，不再执行任何查询语句，这种数据库查询的执行方法称为“延迟加载”


――――――――――――――――
默认 yii\db\ActiveQuery::joinWith() 使用左连接来连接关联表。 你也可以传 $joinType 参数来定制连接类型。 你也可以使用 yii\db\ActiveQuery::innerJoinWith()。
――――――――――――――――――――――――――
关联表操作

AR 提供了下面两个方法用来建立和解除两个关联对象之间的关系：

yii\db\ActiveRecord::link()
yii\db\ActiveRecord::unlink()

――――――――――――――――――――――――――
用域

当你调用yii\db\ActiveRecord::find() 或 yii\db\ActiveRecord::findBySql()方法时，将会返回一个yii\db\ActiveQuery实例。之后，你可以调用其他查询方法，如 yii\db\ActiveQuery::where()，yii\db\ActiveQuery::orderBy(), 进一步的指定查询条件。

有时候你可能需要在不同的地方使用相同的查询方法。如果出现这种情况，你应该考虑定义所谓的作用域。作用域是本质上要求一组的查询方法来修改查询对象的自定义查询类中定义的方法。 之后你就可以像使用普通方法一样使用作用域。


乐观锁（Optimistic Locks）

TODO

被污染属性

――――――――――――――――――――――――――――――――――――――

在控制器中，我们将传递一个模型的实例到视图，其中 yii\widgets\ActiveForm 小部件用来显示表单：

<?php
use yii\helpers\Html;
use yii\widgets\ActiveForm;

$form = ActiveForm::begin([
    'id' => 'login-form',
    'options' => ['class' => 'form-horizontal'],
]) ?>
    <?= $form->field($model, 'username') ?>
    <?= $form->field($model, 'password')->passwordInput() ?>

    <div class="form-group">
        <div class="col-lg-offset-1 col-lg-11">
            <?= Html::submitButton('Login', ['class' => 'btn btn-primary']) ?>
        </div>
    </div>
<?php ActiveForm::end() ?>

――――――――――――――――――――――――――――――
指定模型的属性可以以更复杂的方式来完成。例如，当上传时，多个文件 或选择多个项目的属性，可能需要一个数组值，你可以通过附加 [] 来 指定它的属性名称：

// 允许多个文件被上传：
echo $form->field($model, 'uploadFile[]')->fileInput(['multiple'=>'multiple']);

// 允许进行选择多个项目：
echo $form->field($model, 'items[]')->checkboxList(['a' => 'Item A', 'b' => 'Item B', 'c' => 'Item C']);

――――――――――――――――――――
提示：为了设计带星号的表单字段，你可以使用下面的 CSS：

div.required label:after {
    content: " *";
    color: red;
}

――――――――――――――――――――――――――――――――――――――――
创建下拉列表

可以使用 ActiveForm 的 dropDownList() 方法来创建一个下拉列表：

use app\models\ProductCategory;

/* @var $this yii\web\View */
/* @var $form yii\widgets\ActiveForm */
/* @var $model app\models\Product */

echo $form->field($model, 'product_category')->dropdownList(
    ProductCategory::find()->select(['category_name', 'id'])->indexBy('id')->column(),
    ['prompt'=>'Select Category']
);

――――――――――――――――――――――――
一般说来，程序猿永远不应该信任从最终用户直接接收到的数据， 并且使用它们之前应始终先验证其可靠性。


// populate model attributes with user inputs
$model->load(\Yii::$app->request->post());


验证事件

当调用 yii\base\Model::validate() 方法的过程里，它同时会调用两个特殊的方法， 把它们重写掉可以实现自定义验证过程的目的：

yii\base\Model::beforeValidate()：在默认的实现中会触发 yii\base\Model::EVENT_BEFORE_VALIDATE 事件。 你可以重写该方法或者响应此事件，来在验证开始之前，先进行一些预处理的工作。 （比如，标准化数据输入）该方法应该返回一个布尔值，用于标明验证是否通过。
yii\base\Model::afterValidate()：在默认的实现中会触发 yii\base\Model::EVENT_AFTER_VALIDATE 事件。 你可以重写该方法或者响应此事件，来在验证结束之后， 再进行一些收尾的工作。


条件式验证

若要只在某些条件满足时，才验证相关特性，比如：是否验证某特性取决于另一特性的值， 你可以通过yii\validators\Validator::when 属性来定义相关条件。举例而言，

    ['state', 'required', 'when' => function($model) {
        return $model->country == 'USA';
    }]

――――――――――――――――――
当输入数据是通过 HTML 表单，你经常会需要给空的输入项赋默认值。你可以通过调整 default 验证器来实现这一点。举例来说，

return [
    // 若 "username" 和 "email" 为空，则设为 null
    [['username', 'email'], 'default'],

    // 若 "level" 为空，则设其为 1
    ['level', 'default', 'value' => 1],
];
默认情况下，当输入项为空字符串，空数组，或 null 时，会被视为“空值”。 你也可以通过配置yii\validators\Validator::isEmpty 属性来自定义空值的判定规则。比如，

    ['agree', 'required', 'isEmpty' => function ($value) {
        return empty($value);
    }]


创建验证器（Validators）

除了使用 Yii 的发布版里所包含的核心验证器之外，你也可以创建你自己的验证器。 自定义的验证器可以是行内验证器，也可以是独立验证器。


Note: 缺省状态下，行内验证器不会在关联特性的输入值为空或该特性已经在其他验证中失败的情况下起效。 若你想要确保该验证器始终启用的话，你可以在定义规则时，酌情将 yii\validators\Validator::skipOnEmpty 以及 yii\validators\Validator::skipOnError属性设为 false，比如，

[
    ['country', 'validateCountry', 'skipOnEmpty' => false, 'skipOnError' => false],
]

――――――――――――――――――――――
public function clientValidateAttribute($model, $attribute, $view)
{
    return <<<JS
        deferred.push($.get("/check", {value: value}).done(function(data) {
            if ('' !== data) {
                messages.push(data);
            }
        }));
JS;
}

jquery Deferred objects?


AJAX Validation

Some validations can only be done on the server side, because only the server has the necessary information. For example, to validate if a username is unique or not, it is necessary to check the user table on the server side. You can use AJAX-based validation in this case. It will trigger an AJAX request in the background to validate the input while keeping the same user experience as the regular client-side validation.

To enable AJAX validation for a single input field, configure the yii\widgets\ActiveField::enableAjaxValidation property of that field to be true and specify a unique form id:

use yii\widgets\ActiveForm;

$form = ActiveForm::begin([
    'id' => 'registration-form',
]);

echo $form->field($model, 'username', ['enableAjaxValidation' => true]);

// ...

ActiveForm::end();
To enable AJAX validation for the whole form, configure yii\widgets\ActiveForm::enableAjaxValidation to be true at the form level:

$form = ActiveForm::begin([
    'id' => 'contact-form',
    'enableAjaxValidation' => true,
]);
Note: When the enableAjaxValidation property is configured at both the input field level and the form level, the former will take precedence.
You also need to prepare the server so that it can handle the AJAX validation requests. This can be achieved by a code snippet like the following in the controller actions:

if (Yii::$app->request->isAjax && $model->load(Yii::$app->request->post())) {
    Yii::$app->response->format = Response::FORMAT_JSON;
    return ActiveForm::validate($model);
}
The above code will check whether the current request is an AJAX. If yes, it will respond to this request by running the validation and returning the errors in JSON format.
――――――――――――――――――――――――――――
文件上传skipOnEmpty属性，判断是否允许跳过。

多文件上传，在控制器的 action 方法中，你应该调用 UploadedFile::getInstances() 而不是单文件UploadedFile::getInstance()。

――――――――――――――――――――――――――――――――――

们使用 yii\db\ActiveQuery::indexBy() 来让模型的主键成为一个数组的索引

收集列表输入/单一模型？

数据格式化--By default the formatter is implemented by yii\i18n\Formatter

\Yii::$app->formatter；（\Yii::$app全局访问）


分页---Yii uses a yii\data\Pagination object 

offset起始位置
――――――――――――――――――――
The widget takes a pagination object so that it knows what is the current page and how many page buttons should be displayed. For example,

use yii\widgets\LinkPager;

echo LinkPager::widget([
    'pagination' => $pagination,
]);
――――――――――――――――――――――
If you want to build UI element manually, you may use yii\data\Pagination::createUrl() to create URLs that would lead to different pages.

排序

Yii uses a yii\data\Sort object to represent the information about a sorting schema.

创建排序链接--link()和createUrl()


数据提供者

在 Pagination 和 Sorting 部分, 我们已经介绍了如何允许终端用户选择一个特定的数据页面，根据一些字段对它们进行展现与排序。 因为分页和排序数据的任务是很常见的，所以Yii提供了一组封装好的data provider类。

数据提供者是一个实现了 yii\data\DataProviderInterface 接口的类。 它主要用于获取分页和数据排序。它经常用在 data widgets 小物件里，方便终端用户进行分页与数据排序。

 Active Record 对象--用以访问数据库下面的数据提供者类都包含在Yii的发布版本里面：

yii\data\ActiveDataProvider：使用 yii\db\Query 或者 yii\db\ActiveQuery 从数据库查询数据并且以数组项的方式或者 Active Record 实例的方式返回。
yii\data\SqlDataProvider：执行一段SQL语句并且将数据库数据作为数组返回。
yii\data\ArrayDataProvider：将一个大的数组依据分页和排序规格返回一部分数据。

――――――――――――――――――――――――――――
所有的这些数据提供者遵守以下模式：

// 根据配置的分页以及排序属性来创建一个数据提供者
$provider = new XyzDataProvider([
    'pagination' => [...],
    'sort' => [...],
]);

// 获取分页和排序数据
$models = $provider->getModels();

// 在当前页获取数据项的数目
$count = $provider->getCount();

// 获取所有页面的数据项的总数
$totalCount = $provider->getTotalCount();

你可以通过配置 yii\data\BaseDataProvider::pagination 和 yii\data\BaseDataProvider::sort的属性来设定数据提供者的分页和排序行为。
 属性分别对应于 yii\data\Pagination 和 yii\data\Sort。 你也可以对它们配置false来禁用分页和排序特性。
――――――――――――――――――――――――――――――――――――――
Data widgets,诸如 yii\grid\GridView，有一个属性名叫 dataProvider ，这个属性能够提供一个 数据提供者的示例并且可以显示所提供的数据，例如，

echo yii\grid\GridView::widget([
    'dataProvider' => $dataProvider,
]);

ar方法all()返回所有数据

假如查询已经指定了 orderBy 从句，则终端用户给定的新的排序说明（通过 sort 来配置的） 将被添加到已经存在的从句中。任何已经存在的 limit 和 offset 从句都将被终端用户所请求的分页 （通过 pagination 所配置的）所重写。

queryScalar()--返回第一列第一行数据，该方法存在于command.php

数组数据提供者

yii\data\ArrayDataProvider 非常适用于大的数组。数据提供者允许你返回一个 经过一个或者多个字段排序的数组数据页面。为了使用 yii\data\ArrayDataProvider， 你应该指定 yii\data\ArrayDataProvider::allModels 属性作为一个大的数组。 这个大数组的元素既可以是一些关联数组（例如：DAO查询出来的结果） 也可以是一些对象（例如：Active Record实例） 例如,

use yii\data\ArrayDataProvider;

$data = [
    ['id' => 1, 'name' => 'name 1', ...],
    ['id' => 2, 'name' => 'name 2', ...],
    ...
    ['id' => 100, 'name' => 'name 100', ...],
];

$provider = new ArrayDataProvider([
    'allModels' => $data,
    'pagination' => [
        'pageSize' => 10,
    ],
    'sort' => [
        'attributes' => ['id', 'name'],
    ],
]);

// 获取当前请求页的每一行数据
$rows = $provider->getModels();


注意：数组数据提供者与 Active Data Provider 和 SQL Data Provider 这两者进行比较的话， 会发现数组数据提供者没有后面那两个高效，这是因为数组数据提供者需要加载所有的数据到内存中。

数据键的使用？

bool SplFileObject::eof判断到达文件结束

ActiveRecord是model子类


GridView

数据网格或者说 GridView 小部件是Yii中最强大的部件之一。如果你需要快速建立系统的管理后台， GridView 非常有用。它从数据提供者 data provider 中取得数据并使用 yii\grid\GridView::columns 属性的一组列配置，在一个表格中渲染每一行数据。-- 展现出来的表格封装了排序以及分页功能。


动作列

yii\grid\ActionColumn 用于显示一些动作按钮，如每一行的更新、删除操作。


使用 Gii 去生成为数据表中 数据实现完整 CRUD 功能的代码。

SQL视图用于过滤、排序和显示数据

还有另外一种方法可以更快、更有用 - SQL 视图。例如，我们要在 GridView 中显示用户和他们的简介，可以这样创建 SQL 视图：

CREATE OR REPLACE VIEW vw_user_info AS
    SELECT user.*, user_profile.lastname, user_profile.firstname
    FROM user, user_profile
    WHERE user.id = user_profile.user_id


数据小部件

Yii提供了一套数据小部件 widgets ，这些小部件可以用于显示数据。 DetailView 小部件能够用于显示一条记录数据， ListView 和 GridView 小部件能够用于显示一个拥有分页、 排序和过滤功能的一个列表或者表格。


istView

yii\widgets\ListView 小部件用于显示数据提供者 data provider 提供的数据。 每个数据模型用指定的视图文件 yii\widgets\ListView::$itemView 来渲染。 因为它提供开箱即用式的（译者注：封装好的）分页、排序以及过滤这样一些特性， 所以它可以很方便地为最终用户显示信息并同时创建数据管理界面。

每个列类是从 yii\grid\Column 扩展而来

表格列

数据列

动作列

复选框列

yii\grid\CheckboxColumn 显示一个复选框列。

序列号

在过滤条件中，别名必须使用，但属性名称保持不变
个页面多个网格视图部件
――――――――――――――――――――――――――――――
单个页面多个网格视图部件

你可以在一个单独页面中使用多个网格视图，但是一些额外的配置是必须的，为的就是它们相互之间不干扰。 当使用多个网格视图实例的时候，你必须要为生成的排序和分页对象配置不同的参数名， 以便于每个网格视图有它们各自独立的排序和分页。

生产环境--开发环境--调试环境
――――――――――――――――――――――――――――――
客户端脚本使用

注册脚本

你可以使用 yii\web\View 对象注册脚本。这里有两个专门的方法： （1）yii\web\View::registerJs() 用于内联脚本。 （2）yii\web\View::registerJsFile() 用于注册引入外部脚本文件。 内联脚本通常用于配置和动态生成代码。


加载js/css文件推荐优先使用资源包而非直接使用CSS和JavaScript，对于高流量的网站来说，这是比较理想的方式。

 至于怎样使用已经定义的资源包，这很简单：

\frontend\assets\AppAsset::register($this);

在这种情况下，依赖资源包就是 yii\bootstrap\BootstrapAsset。这意味着CSS文件将 被添加在 yii\bootstrap\BootstrapAsset 之后。

主题是一种将当前的一套视图 views 替换为另一套视图，而无需更改视图渲染代码的方法。 你可以使用主题来系统地更改应用的外观和体验。

yii2类继承关系，很多类有继承关系***************************************

主题目录包含了视图文件和布局文件。

@路径别名

主题化模块

主题化小部件

主题继承

*******************************************************************
类继承：
ActiveRecord->BaseActiveRecord

yii/base/application.php

yii/yii.php

yii/base/Security.php

*******************************************************************
yii.php在应用初始化会被优先加载


Yii提供了一个认证框架，它连接了不同的组件以支持登录。欲使用这个框架， 你主要需要做以下工作：

设置用户组件 yii\web\User ;
创建一个类实现 yii\web\IdentityInterface 接口。


授权是指验证用户是否允许做某件事的过程。Yii提供两种授权方法： 存取控制过滤器（ACF）和基于角色的存取控制（RBAC）。

Yii 实现了通用的分层的 RBAC，遵循的模型是 NIST RBAC model. 它通过 yii\rbac\ManagerInterface application component 提供 RBAC 功能。

使用 RBAC 涉及到两部分工作。第一部分是建立授权数据， 而第二部分是使用这些授权数据在需要的地方执行检查。


角色是 权限 的集合 （例如：建贴、改贴）。一个角色 可以指派给一个或者多个用户。要检查某用户是否有一个特定的权限， 系统会检查该包含该权限的角色是否指派给了该用户。


配置 RBAC

在开始定义授权数据和执行存取检查之前，需要先配置应用组件 yii\base\Application::authManager 。 Yii 提供了两套授权管理器： yii\rbac\PhpManager 和 yii\rbac\DbManager。前者使用 PHP 脚本存放授权数据， 而后者使用数据库存放授权数据。 如果你的应用不要求大量的动态角色和权限管理， 你可以考虑使用前者。

【使用 PhpManager

以下代码展示使用 yii\rbac\PhpManager 时如何在应用配置文件中配置 authManager：

return [
    // ...
    'components' => [
        'authManager' => [
            'class' => 'yii\rbac\PhpManager',
        ],
        // ...
    ],
];
现在可以通过 \Yii::$app->authManager 访问 authManager 。】

DbManager 使用4个数据库表存放它的数据：

yii\rbac\DbManager::$itemTable： 该表存放授权条目（译者注：即角色和权限）。默认表名为 "auth_item" 。
yii\rbac\DbManager::$itemChildTable： 该表存放授权条目的层次关系。默认表名为 "auth_item_child"。
yii\rbac\DbManager::$assignmentTable： 该表存放授权条目对用户的指派情况。默认表名为 "auth_assignment"。
yii\rbac\DbManager::$ruleTable： 该表存放规则。默认表名为 "auth_rule"。
继续之前，你需要在数据库中创建这些表。你可以使用存放在 @yii/rbac/migrations 目录中的数据库迁移文件来做这件事

――――――――――――――――――――――――――――――――
建立授权数据

所有授权数据相关的任务如下：

定义角色和权限；
建立角色和权限的关系；
定义规则；
将规则与角色和权限作关联；
指派角色给用户。

――――――――――――――――――――
使用默认角色

所谓默认角色就是 隐式 地指派给 所有 用户的角色。不需要调用 yii\rbac\ManagerInterface::assign() 方法做显示指派，并且授权数据中不包含指派信息。

默认角色通常与一个规则关联，用以检查该角色是否符合被检查的用户。

默认角色常常用于已经确立了一些角色的指派关系的应用

现在如果你执行一个存取权限检查--需要手动调用

处理密码--为了即使在最糟糕的情况下（你的应用程序被破解了）也能给用户密码提供增强的安全性， 你需要使用一个能够对抗暴力破解攻击的哈希算法。目前最好的选择是 bcrypt。在 PHP 中， 你可以通过 crypt 函数 生成 bcrypt 哈希。 Yii 提供了两个帮助函数以让使用 crypt 来进行安全的哈希密码生成和验证更加容易。

――――――――――――――――――――――――――――
【最佳安全实践--无论是开发何种应用程序，我们都有两条基本的安全准则：

过滤输入
转义输出】

转义输出

转义输出的意思是，根据我们使用数据的上下文环境，数据需要被转义。比如：在 HTML 上下文， 你需要转义 <，> 之类的特殊字符。在 JavaScript 或者 SQL 中，也有其他的特殊含义的字符串需要被转义。 由于手动的给所用的输出转义容易出错， Yii 提供了大量的工具来在不同的上下文执行转义。


避免 SQL 注入

SQL 注入发生在查询语句是由连接未转义的字符串生成的场景

XSS或者跨站脚本发生在输出 HTML 到浏览器时，输出内容没有正确的转义。

CSRF跨站请求伪造-- $enableCsrfValidation=true是否开启csrf攻击
――――――――――――――――――――――――――――――――――――――――

缓存是提升 Web 应用性能简便有效的方式。

Yii 支持如上所有缓存机制：

数据缓存
片段缓存
页面缓存
HTTP 缓存

所有缓存组件都有同样的基类 yii\caching\Cache 
――――――――――――――――――――――――――――――――――――――
缓存组件

数据缓存需要缓存组件提供支持，它代表各种缓存存储器， 例如内存，文件，数据库。

缓存组件通常注册为应用程序组件，这样 它们就可以在全局进行配置与访问。 

Yii 支持一系列缓存存储器：
【yii\caching\ApcCache：使用 PHP APC 扩展。】
【yii\caching\DummyCache: 仅作为一个缓存占位符，不实现任何真正的缓存功能。】【yii\caching\MemCache：使用 PHP memcache 和 memcached 扩展。】
【yii\caching\WinCache：使用 PHP WinCache （另可参考 ）扩展。】
【yii\caching\XCache：使用 PHP XCache扩展。】

有些缓存存储器如 MemCache，APC 支持以批量模式取回缓存值，这样可以节省取回 缓存数据的开支。如果底层缓存存储器不支持该特性，Yii 也会模拟实现。
――――――――――――――――――――――――――――――――――――――――
由于 yii\caching\Cache 实现了 PHP ArrayAccess 接口，缓存组件也可以像数组那样使用， 下面是几个例子：

$cache['var1'] = $value1;  // 等价于： $cache->set('var1', $value1);
$value2 = $cache['var2'];  // 等价于： $value2 = $cache->get('var2');

――――――――――――――――――――――――
缓存键

存储在缓存中的每项数据都通过键作唯一识别。当你在缓存中存储一项 数据时，必须为它指定一个键，稍后从缓存中取回数据时，也需要提供 相应的键。

你可以使用一个字符串或者任意值作为一个缓存键。当键不是一个字符串时，它将会自动 被序列化为一个字符串。
――――――――――――――――――――――――――
当同一个缓存存储器被用于多个不同的应用时，应该为每个应用指定一个唯一的缓存键前缀 以避免缓存键冲突。可以通过配置 yii\caching\Cache::keyPrefix 属性实现。例如，在应用配置中可以编写如下代码：

'components' => [
    'cache' => [
        'class' => 'yii\caching\ApcCache',
        'keyPrefix' => 'myapp',       // 唯一键前缀
    ],
],

――――――――――――――――――――――――――――――
缓存过期

默认情况下，缓存中的数据会永久存留，除非它被某些缓存策略强制移除

――――――――――――――――――――――――――
缓存依赖

除了超时设置，缓存数据还可能受到缓存依赖的影响而失效。 例如，yii\caching\FileDependency 代表对一个文件修改时间的依赖。 这个依赖条件发生变化也就意味着相应的文件已经被修改。 因此，缓存中任何过期的文件内容都应该被置为失效状态， 对 yii\caching\Cache::get() 的调用都应该返回 false。

――――――――――――――――――――――――――

           BEGIN
             sql_stat := 'INSERT INTO tb2 VALUES(:1,:2,:3,:4)';                --DML语句中使用了占位符
             EXECUTE IMMEDIATE sql_stat USING lv_empno, lv_ename,lv_sal,30;    --为占位符指定参数或值
             COMMIT;
           END;

――――――――――――――――――――
When you need to invalidate all the stored cache data, you can call yii\caching\Cache::flush().

――――――――――――――――――――――――――――――――――――――
If you just want to use query caching for a single query, you can call yii\db\Command::cache() when building the command. For example,

// use query caching and set query cache duration to be 60 seconds
$customer = $db->createCommand('SELECT * FROM customer WHERE id=1')->cache(60)->queryOne();


限制条件

有些缓存存储器有大小限制。例如，memcache 限制每条数据 最大为 1MB。因此，如果查询结果的大小超出了该限制， 则会导致缓存失败。

――――――――――――――――――――――――――――
片段缓存

片段缓存指的是缓存页面内容中的某个片段。例如，一个页面显示了逐年销售额的摘要表格， 可以把表格缓存下来，以消除每次请求都要重新生成表格 的耗时。片段缓存是基于数据缓存实现的。

在视图中使用以下结构启用片段缓存：

if ($this->beginCache($id)) {

    // ... 在此生成内容 ...

    $this->endCache();
}

――――――――――――――――――――――――――――――――――
缓存选项：1、过期时间（duration）2、依赖3、变化4、开关--可以使用 yii\widgets\FragmentCache::enabled 选项来指定缓存开关
缓存嵌套
缓存中输出动态内容--yii\base\View::renderDynamic() 方法接受 一段 PHP 代码作为参数。代码的返回值被看作是动态内容。

――――――――――――――――――――――――――――
页面缓存

页面缓存指的是在服务器端缓存整个页面的内容。随后当同一个页面 被请求时，内容将从缓存中取出，而不是重新生成。

页面缓存由 yii\filters\PageCache 类提供支持，该类是一个 过滤器。它可以像这样在控制器类中使用：

public function behaviors()
{
    return [
        [
            'class' => 'yii\filters\PageCache',
            'only' => ['index'],
            'duration' => 60,
            'variations' => [
                \Yii::$app->language,
            ],
            'dependency' => [
                'class' => 'yii\caching\DbDependency',
                'sql' => 'SELECT COUNT(*) FROM post',
            ],
        ],
    ];
}
上述代码表示页面缓存只在 index 操作时启用，页面内容最多被缓存 60 秒，会随着当前应用的语言更改而变化。如果文章总数发生变化则缓 存的页面会失效。

如你所见，页面缓存和片段缓存极其相似。它们都支持 duration，dependencies， variations 和 enabled 配置选项。它们的主要区别是页面缓存是由过滤器实现， 而片段缓存则是一个小部件。

你可以在使用页面缓存的同时，使用片段缓存和 动态内容。
――――――――――――――――――――――――――――――――――――――――
配置URL规则

然后，修改有关在应用程序配置的urlManager组件的配置：

'urlManager' => [
    'enablePrettyUrl' => true,
    'enableStrictParsing' => true,
    'showScriptName' => false,
    'rules' => [
        ['class' => 'yii\rest\UrlRule', 'controller' => 'user'],
    ],
]
上面的配置主要是为user控制器增加一个 URL 规则。这样， 用户的数据就能通过美化的 URL 和有意义的 http 动词进行访问和操作。

启用 JSON 输入

为了使 API 接收 JSON 格式的输入数据，配置 request 应用程序组件的 yii\web\Request::$parsers 属性使用 yii\web\JsonParser 用于JSON输入：

'request' => [
    'parsers' => [
        'application/json' => 'yii\web\JsonParser',
    ]
]

resetful web重新看
――――――――――――――――――――――――――――――――――
当RESTful API响应中包含一个资源时，该资源需要序列化成一个字符串。 Yii将这个过程分成两步，首先，资源会被yii\rest\Serializer转换成数组， 然后，该数组会通过yii\web\ResponseFormatterInterface 根据请求格式(如JSON, XML)被序列化成字符串。

服务提供者？

和Web应用不同，RESTful APIs 通常是无状态的， 也就意味着不应使用sessions 或 cookies， 因此每个请求应附带某种授权凭证，因为用户授权状态可能没通过sessions 或 cookies维护， 常用的做法是每个请求都发送一个秘密的access token来认证用户， 由于access token可以唯一识别和认证用户， API 请求应通过HTTPS来防止man-in-the-middle (MitM) 中间人攻击.



如果你系那个支持以上3个认证方式，可以使用CompositeAuth

――――――――――――――――――――
为防止滥用，你应该考虑增加速率限制到您的 API。 例如，您可以限制每个用户的 API 的使用是在 10 分钟内最多 100 次的 API 调用。 如果一个用户在规定的时间内太多的请求被接收，将返回响应状态代码 429 (这意味着过多的请求)。
――――――――――――――――――――――――――――
应用程序配置：
return [
    'modules' => [
        'v1' => [
            'basePath' => '@app/modules/v1',
        ],
        'v2' => [
            'basePath' => '@app/modules/v2',
        ],
    ],
    'components' => [
        'urlManager' => [
            'enablePrettyUrl' => true,
            'enableStrictParsing' => true,
            'showScriptName' => false,
            'rules' => [
                ['class' => 'yii\rest\UrlRule', 'controller' => ['v1/user', 'v1/post']],
                ['class' => 'yii\rest\UrlRule', 'controller' => ['v2/user', 'v2/post']],
            ],
        ],
    ],
];

――――――――――――――――――――――――――
单元测试验证了一个单元代码是否正如预期那样运行工作。 在面向对象程序设计 中，最基本的代码单元就是类。

高级模板有三个应用：前台、后台和控制台。前台通常面向终端用户，项目自身。后台是管理平台，有数据分析等功能。控制台通常用于守护作业和底层服务器管理，也用于应用部署、数据库迁移和资源管理。

――――――――――――――――――――――――――
调试工具栏和调式器
Yii2 包括了一个方便的工具栏和内置的调试器来更快的开发和调试你的应用。

――――――――――――――――――――――――
高级应用模板使用：
安装应用后，必须执行以下步骤来初始化应用，只需做一次：

执行 init 命令并选择 dev 环境。

1
php /path/to/yii-application/init
创建新的数据库并在 common/config/main-local.php 相应地调整 components db 配置。
以控制台命令 yii migrate 运行数据库合并。
设置 web 服务器的文件根目录：

前台是 /path/to/yii-application/frontend/web/ ，使用 http://frontend/ 访问。
后台是 /path/to/yii-application/backend/web/ ，使用 http://backend/ 访问。
――――――――――――――――――――――――――――――――――――
应用模板配置

，你需要修改 composer.json 以配置你自己的模板。修改 name, description, keywords, homepage, license, 和 support 的值来描述你自己的模板。

控制台命令

除了用于构建 Web 应用程序的丰富功能，Yii 中也有一个拥有丰富功能的控制台， 它们主要用于创建网站后台处理的任务。

控制台应用程序的结构非常类似于 Yii 的一个 Web 应用程序。 它由一个或多个 yii\console\Controller 类组成，它们在控制台环境下通常被称为“命令”。 每个控制器还可以有一个或多个动作，就像 web 控制器。

――――――――――――――――――――――――――――――――
验证码--yii\captcha\CaptchaValidator

[
    ['verificationCode', 'captcha'],
]
该验证器通常配合 yii\captcha\CaptchaAction 以及 yii\captcha\Captcha 使用

国际化

国际化（I18N）是指在设计软件时，使它可以无需做大的改变就能够适应不同的语言和地区的需要。对于 Web 应用程序， 这有着特别重要的意义，因为潜在的用户可能会在全球范围内。 Yii 提供的国际化功能支持全方位信息翻译， 视图翻译，日期和数字格式化。
――――――――――――――――――――――――――――――――――
在 Yii中，我们经常用 “language” 来代表一个区域。

一个 Yii 应用使用两种语言：yii\base\Application::$sourceLanguage 和 yii\base\Application::$language 。 前者指的是写在代码中的语言，后者是向最终用户显示内容的语言。 而信息翻译服务主要是将文本消息从原语言翻译到目标语言。

可以用类似下面的应用程序配置来配置应用程序语言：

return [
    // 设置目标语言为俄语
    'language' => 'ru-RU',
    
    // 设置源语言为英语
    'sourceLanguage' => 'en-US',
    
    ......
];
――――――――――――――――――――――――――
t()-- Yii::t() 方法会调用 i18n 应用组件 来实现翻译工作。


预定义的路径别名
@yii - 框架目录
@app - 当前运行应用的根路径
@common - 通用目录
@frontend - web 应用前台目录
@backend - web 应用后台目录
@console - 控制台目录
@runtime - 当前运行 web 应用的运行期目录
@vendor - Composer 包目录
@web - 当前运行 web 应用的 URL
@webroot - 当前运行 web 应用的 web 入口目录

以上路径在application.php定义，配合module.php


Yii 提供一系列常用的核心验证器，主要存在于yii\validators命名空间之下。
――――――――――――――――――――――
布尔型验证器---该验证器检查输入值是否为一个布尔值。

trueValue： 代表真的值。默认为'1'。
falseValue：代表假的值。默认为 '0'。
strict：是否要求待测输入必须严格匹配trueValue或falseValue。默认为false。
注意：因为通过 HTML 表单传递的输入数据都是字符串类型，所以一般情况下你都需要保持 [[yii\validators\BooleanValidator::strict|strict]] 属性为假。
――――――――――――――――――――――――――
电子邮件验证--enableIDN：验证过程是否应该考虑 IDN（internationalized domain names，国际化域名，也称多语种域名，比如中文域名）。默认为 false。要注意但是为使用 IDN 验证功能，请先确保安装并开启 intl PHP 扩展，不然会导致抛出异常。
――――――――――――――――――――――――――――――

安全（safe）
[
    // 标记 "description" 为安全特性
    ['description', 'safe'],
]
该验证器并不进行数据验证。而是把一个特性标记为安全特性。

yii：t（)--消息格式化

在要翻译的消息里，你可以嵌入一些占位符，并让它们通过动态的参数值来代替。 你甚至可以根据目标语言格式的参数值来使用特殊的占位符。 在本节中，我们将介绍如何用不同的方式来格式化消息。

前面的例子说明了如何使用名称占位符。即每个占位符的格式为 {参数名称} ，你所提供的参数作为关联数组， 其中数组的键是参数名称（没有大括号）， 数组的值是对应的参数值。

位置占位符是使用基于零的整数序列，在调用 Yii::t() 时会参数值根据它们出现位置的顺序分别进行替换。 在下面的例子中，位置占位符 {0}，{1} 和 {2} 将分别被 $price，$count 和 $subtotal 所替换。

格式化参数

你可以在消息的占位符指定附加格式的规则， 这样的参数值可在替换占位符之前格式化它们。

你可以指定参数的格式为 integer（整型），currency （货币），或者 percent （百分数）
******注意：参数的格式化需要安装 intl PHP 扩展。**********

――――――――――――――――――――――――――――
格式化参考。

时间

参数值应该被格式化为一个时间。 例如，

echo \Yii::t('app', 'It is {0, time}', time());
你可以指定一个可选的参数格式 short ，medium ，long ，或 full ：

echo \Yii::t('app', 'It is {0, time, short}', time());
你还可以指定一个自定义模式来格式化时间：

echo \Yii::t('app', 'It is {0, date, HH:mm}', time());
――――――――――――――――――――――
yii/base/Module.php


――――――
收发邮件--大多数情况下你可以使用 yii2-swiftmailer 官方扩展

性能优化：
1、禁止调试模式
你可以将下面的代码行放在 入口脚本 的开头来禁用调试模式：

defined('YII_DEBUG') or define('YII_DEBUG', false);
2、使用缓存技术--开启 Schema 缓存
3、合并和压缩资源文件
4、优化会话存储---默认会话数据被存储在文件中。 这是好的对处于发展项目或小型项目。 但是，当涉及要处理大量并发请求时， 最好使用其他的会话存储方式，比如数据库。

注意，尽管索引可以使选择查询的速度快得多，但它会减慢插入、更新和删除的查询。

――――――――――――――――――――――――――
使用模板引擎

默认情况下，Yii 使用 PHP 作为其默认的模板引擎语言，但是，你可以配置 Yii 以扩展的方式支持其他的渲染引擎， 比如 Twig 或 Smarty等。

组件 view 就是用于渲染视图的

Yii 提供许多类来简化常见编码，如对字条串或数组的操作， HTML 代码生成，等等。这些助手类被编写在命名空间 yii\helpers 下，并且 全是静态类 （就是说它们只包含静态属性和静态方法，而且不能实例化）。

【
一旦 Gii 扩展被正确安装，你可以通过在应用配置文件中添加下面这块代码来启用它：
modules' => [
    'gii' => [
        'class' => 'yii\gii\Module',
    ],
]

启用Gii之后，你就可以通过如下URL访问Gii：

1
http://localhost/path/to/index.php?r=gii

如果你开启了 pretty URLs ，你可能需要通过如下URL访问Gii：
2
http://localhost/path/to/index.php/gii】

开启 pretty URLs 

Yii asset manager 

bootstrap组件都在--yii\bootstrap下

Yii框架的类通常都是从两个基础类扩展而来：[[yii\base\Object]] 或 [[yii\base\Component]]。这两个类为扩展类自动提供了很多有用的功能。

Object 类提供配置和属性功能（ configuration and property feature）。Component 类扩展自 Object 并添加了事件处理和行为特性（event handling 和 behaviors）。

一个同名（ alias ）必须以 @ 符号开始，这样可以和文件、目录的路径以及URL链接区别开来。

组件使用--component做相应配置

extension.php

在一个应用中，至少要配置2个属性: yii\base\Application::id 和 yii\base\Application::basePath。

【对象配置
Object 类引入了一个配置对象的统一方法。任何 Object 类的继承者在需要的时候都应该使用如下的方法来声明其构造函数，这样才能被正确的配置：


class MyClass extends \yii\base\Object
{
    public function __construct($param1, $param2, $config = [])
    {
        // ... initialization before configuration is applied
 
        parent::__construct($config);//后
    }
 
    public function init()
    {
        parent::init(); //前
 
        // ... initialization after configuration is applied
    }
}】

applition.php init()方法谁调用？
应用配置参数相应介绍在applition.php，配置组件有很多，db也是组件。

每一个应用组件指定一个key-value对的数组，key代表组件ID， value代表组件类名或 配置。

在应用中可以任意注册组件， 并可以通过表达式 \Yii::$app->ComponentID 全局访问。

组件配置--3中方式：类名、数组、函数。

Yii 定义了一组固定ID和默认配置的 核心 组件，例如 yii\web\Application::request 组件 用来收集用户请求并解析 路由； 

【yii\base\Application::controllerMap

该属性允许你指定一个控制器ID到任意控制器类。 Yii遵循一个默认的 规则指定控制器ID到任意控制器类（如post对应app\controllers\PostController）。 通过配置这个属性，可以打破这个默认规则，在下面的例子中， account对应到app\controllers\UserController， article 对应到 app\controllers\PostController。

[
    'controllerMap' => [
        [
            'account' => 'app\controllers\UserController',
            'article' => [
                'class' => 'app\controllers\PostController',
                'enableCsrfValidation' => false,
            ],
        ],
    ],
]
数组的键代表控制器ID， 数组的值代表对应的类名。】

【Yii遵循一个默认的 规则指定控制器ID到任意控制器类（如post对应app\controllers\PostController）。控制器类全面能被 自动加载，这点是非常重要的， 控制器类的实际命名空间对应这个属性， 否则，访问时你会收到"Page Not Found"。】 


【yii\base\Application::controllerNamespace

该属性指定控制器类默认的命名空间，默认为app\controllers。】

【yii\base\Application::language

该属性指定应用展示给终端用户的语言， 默认为 en 标识英文。 如果需要之前其他语言可以配置该属性。

该属性影响各种 国际化 ， 包括信息翻译、日期格式、数字格式等。 例如 yii\jui\DatePicker 小部件会 根据该属性展示对应语言的日历以及日期格式。】


yii\base\Application::modules

该属性指定应用所包含的 模块。

该属性使用数组包含多个模块类 配置， 数组的键为模块ID，例：

[
    'modules' => [
        // "booking" 模块以及对应的类
        'booking' => 'app\modules\booking\BookingModule',

        // "comment" 模块以及对应的配置数组
        'comment' => [
            'class' => 'app\modules\comment\CommentModule',
            'db' => 'db',
        ],
    ],
]

【Yii.php继承BaseYii.php】
我们把通过 Yii::setAlias() 定义的别名称为根别名，而用他们衍生出去的别名成为衍生别名。


@yii路径C:\Users\Administrator\PhpstormProjects\untitled8\vendor\yiisoft\yii2

@app路径C:\Users\Administrator\PhpstormProjects\untitled8

@web路径

@webroot路径C:/Users/Administrator/PhpstormProjects/untitled8/web

@vendor路径C:\Users\Administrator\PhpstormProjects\untitled8\vendor

【解析别名

你可以调用 Yii::getAlias() 命令来解析根别名到对应的文件路径或 URL。 同样的页面也可以用于解析衍生别名。例如：

echo Yii::getAlias('@foo');               // 输出：/path/to/foo
echo Yii::getAlias('@bar');               // 输出：http://www.example.com
echo Yii::getAlias('@foo/bar/file.php');  // 输出：/path/to/foo/bar/file.php】

【使用别名

别名在 Yii 的很多地方都会被正确识别，无需调用 Yii::getAlias() 来把它们转换为路径/URL。例如，yii\caching\FileCache::cachePath 能同时接受文件路径或是指向文件路径的别名， 因为通过 @ 前缀能区分它们。

use yii\caching\FileCache;

$cache = new FileCache([
    'cachePath' => '@runtime/cache',
]);】

【yii2/message/下为语言包】

每一个通过 Composer 安装的 扩展 都自动添加了一个别名。 该别名会以该扩展在 composer.json 文件中所声明的根命名空间为名，且他直接代指该包的根目录。 例如，如果你安装有 yiisoft/yii2-jui 扩展， 会自动得到 @yii/jui 别名，它定义于引导启动阶段。

【组件是 Yii 应用的主要基石。是 yii\base\Component 类或其子类的实例。 三个用以区分它和其它类的主要功能有：

属性（Property）
事件（Event）
行为（Behavior）

当继承 yii\base\Component 或 yii\base\Object 时， 推荐你使用如下的编码风格：

若你需要重写构造方法（Constructor），传入 $config 作为构造器方法最后一个参数， 然后把它传递给父类的构造方法。
永远在你重写的构造方法结尾处调用一下父类的构造方法。
如果你重写了 yii\base\Object::init() 方法，请确保你在 init 方法的开头处调用了父类的 init 方法。
】
【$container容器实现依赖注入】
【container.php里面的get()实现类、属性依赖注入，set()注册类到容器】

【。可以使用 yii\di\Container::setSingleton() 注册一个单例的依赖关系：

$container->setSingleton('yii\db\Connection', [
    'dsn' => 'mysql:host=127.0.0.1;dbname=demo',
    'username' => 'root',
    'password' => '',
    'charset' => 'utf8',
]);】

【以你可以通过 Yii::$container 全局性地自定义这些对象，来改变属性

例如，你可以全局性自定义 yii\widgets\LinkPager 中分页按钮的默认数量:

\Yii::$container->set('yii\widgets\LinkPager', ['maxButtonCount' => 5]);】

数组定义多是--索引数组

【另一个例子是借用 DI 容器中自动构造方法注入带来的好处。假设你的控制器类依赖一些其他对象，例如一个旅馆预订服务。你可以通过一个构造器参数声明依赖关系，然后让 DI 容器帮你自动解决这个依赖关系。

namespace app\controllers;

use yii\web\Controller;
use app\components\BookingInterface;

class HotelController extends Controller
{
    protected $bookingService;

    public function __construct($id, $module, BookingInterface $bookingService, $config = [])
    {
        $this->bookingService = $bookingService;
        parent::__construct($id, $module, $config);
    }
}
如果你从浏览器中访问这个控制器，你将看到一个报错信息，提醒你 BookingInterface 无法被实例化。这是因为你需要告诉 DI 容器怎样处理这个依赖关系。

\Yii::$container->set('app\components\BookingInterface', 'app\components\BookingService');
现在如果你再次访问这个控制器，一个 app\components\BookingService 的实例就会被创建并被作为第三个参数注入到控制器的构造器中。】

【容器继承组件,服务定位器继承组件】
【有2个controller.php文件yii/web/controller.php和yii/base/controller.php，】
【有2个application.php文件yii/web/application.php和yii/base/application.php，】

Yii::$app--实例化在yii/base/application.php中

【依赖注入与服务定位器区别总结:服务定位器主要用来获取组件及配置组件，依赖注入主要用来配置类对象或者返回对象】

【$config配置的component属性为用户组件，需要与核心组件合并】
$config的组件作用？初始化应用配置，用到yii/base/applition.php里面的coreComponents()方法。

yii/base命名空间下是应用程序基类文件夹

object中存在getter 和 setter 方法定义属性

【行为继承自对象object,附加到 yii\base\Component 类或其子类，它将“注入”它的方法和属性到组件，然后可以像访问组件内定义的方法和属性一样访问它们，此外，行为通过组件能响应被触发的事件， 从而自定义或调整组件正常执行的代码】

行为分定义行为/附加行为（静态与动态附加行为）/使用行为/移除行为

【定义行为--
namespace app\components;

use yii\base\Behavior;

class MyBehavior extends Behavior
{
    public $prop1;

    private $_prop2;

    public function getProp2()
    {
        return $this->_prop2;
    }

    public function setProp2($value)
    {


        $this->_prop2 = $value;
    }

    public function foo()
    {
        // ...
    }
}】
$this->_prop2自动获取值

【处理事件

如果要让行为响应对应组件的事件触发， 就应覆写 yii\base\Behavior::events() 方法，如：

namespace app\components;

use yii\db\ActiveRecord;
use yii\base\Behavior;

class MyBehavior extends Behavior
{
    // 其它代码

    public function events()
    {
        return [
            ActiveRecord::EVENT_BEFORE_VALIDATE => 'beforeValidate',
        ];
    }

    public function beforeValidate($event)
    {
        // 处理器方法逻辑
    }
}
yii\base\Behavior::events() 方法返回事件列表和相应的处理器。 上例声明了 yii\db\ActiveRecord::EVENT_BEFORE_VALIDATE 事件和它的处理器 beforeValidate() 。】

controller.php控制器类继承component类，可添加component里面的behavior()方法附加行为。

【要静态附加行为，覆写行为要附加的组件类的 yii\base\Component::behaviors() 方法即可。 yii\base\Component::behaviors() 方法应该返回行为配置列表。 每个行为配置可以是行为类名也可以是配置数组。】

【要动态附加行为，在对应组件里调用 yii\base\Component::attachBehavior() 方法即可】

【可以通过 yii\base\Component::attachBehaviors() 方法一次附加多个行为】

【使用 TimestampBehavior，这个行为支持在 yii\db\ActiveRecord 存储时自动更新它的时间戳属性

yii\behaviors\TimestampBehavior 行为还提供了一个有用的方法 yii\behaviors\TimestampBehavior::touch()， 这个方法能将当前时间戳赋值给指定属性并保存到数据库：

$user->touch('login_time');
】

【Yii 使用事件来注入定制代码到既有代码中的特定执行点。基事件路径- yii\base\Event；事件继承自object类，行为behavior类也有事件--yii\base\Behavior::events() 方法返回事件列表和相应的处理器；


事件处理器分实例级别和类级别，】

【所谓全局事件实际上是一个基于以上叙述的事件机制的戏法。它需要一个全局可访问的单例，如应用实例。】
【相应的控制器、模型、视图存在yii/base/controllerEvent.php】

控制器类实例需要参数，模型类实例化不需要参数。


模型属性访问--$model['name'] /$model->name

高级模型活动记录命名空间yii/db/ActiveRecord

【如果你不想用自动生成属性的标签， 可以覆盖 yii\base\Model::attributeLabels() 方法明确指定属性标签，例如：

namespace app\models;

use yii\base\Model;

class ContactForm extends Model
{
    public $name;
    public $email;
    public $subject;
    public $body;

    public function attributeLabels()
    {
        return [
            'name' => 'Your name',
            'email' => 'Your email address',
            'subject' => 'Subject',
            'body' => 'Content',
        ];
    }
}】

【ActiveRecord 继承model继承component】

【场景--模型类都是继承yii\db\ActiveRecord， 因为多场景的使用通常发生在Active Record 类中.；场景特性主要在验证 和 属性块赋值 中使用。】

【通过覆盖 yii\base\Model::rules() 方法指定 模型属性应该满足的规则来申明模型相关验证规则。


有时你想一条规则只在某个 场景 下应用， 为此你可以指定规则的 on 属性，值只会属于scenarios()中定义的活动属性，如下所示:

public function rules()
{
    return [
        // 在"register" 场景下 username, email 和 password 必须有值
        [['username', 'email', 'password'], 'required', 'on' => 'register'],

        // 在 "login" 场景下 username 和 password 必须有值
        [['username', 'password'], 'required', 'on' => 'login'],
    ];
}
】

接将输入数据对应填充到 yii\base\Model::attributes 属性不存在？

【操作数据库数据是模型继承ActiveRecord高级模型类】

【事件定义用法：
        $foo=new Country();
        $foo->on($foo::EVENT_HELLO, [$foo, 'sendMail']);
       $foo->trigger($foo::EVENT_HELLO);

*说明sendMail为在Country类定义的方法，EVENT_HELLO为类定义的事件名

】

【当我们使用基本应用模版时，可以把你的类放置在顶级命名空间 app 下， 这样它们就可以被 Yii 自动加载，而无需定义一个新的别名。 这是因为 @app 本身是一个预定义别名，且类似于 app\components\MyClass 这样的类名， 基于我们刚才所提到的算法，可以正确解析出 AppBasePath/components/MyClass.php 路径。

在高级应用模版里，每一逻辑层级会使用他自己的根别名。 比如，前端层会使用 @frontend 而后端层会使用 @backend。 因此，你可以把前端的类放在 frontend 命名空间，而后端的类放在 backend。 这样这些类就可以被 Yii 自动加载了。】

【视图和模型定义命名空间】
【yii.php也可以自动加载扩展类，唯一的要求是它需要在 composer.json 文件里正确地定义 autoload 部分】

【组件继承component或者子类，相比其他类更重量级，component继承自object类】

【开启cookie验证：开启应用配置
return [
    'components' => [
        'request' => [
            'cookieValidationKey' => 'fill in a secret key here',
        ],
    ],
];

】

【yii\web\Session 类默认存储session数据为文件到服务器上；
session变量存储--
// 推荐使用带通用前缀的键来存储数组
$session['captcha.number'] = 5;
$session['captcha.lifetime'] = 3600;】

【应用主体--概念

应用主体是管理 Yii 应用系统整体结构和生命周期的对象。 每个Yii应用系统只能包含一个应用主体， 应用主体在 入口脚本 中创建并能通过表达式 \Yii::$app 全局范围内访问。】

【模块是独立的软件单元，由模型, 视图, 控制器和其他支持组件组成， 终端用户可以访问在应用主体中已安装的模块的控制器， 模块被当成小应用主体来看待，和应用主体不同的是， 模块不能单独部署，必须属于某个应用主体。

该属性使用数组包含多个模块类 配置， 数组的键为模块ID，例：

[
    'modules' => [
        // "booking" 模块以及对应的类
        'booking' => 'app\modules\booking\BookingModule',

        // "comment" 模块以及对应的配置数组
        'comment' => [
            'class' => 'app\modules\comment\CommentModule',
            'db' => 'db',
        ],
    ],
]
】

【模块类

每个模块都有一个继承yii\base\Module的模块类， 该类文件直接放在模块的yii\base\Module::basePath目录下， 并且能被 自动加载。 当一个模块被访问，和 应用主体实例 类似会创建该模块类唯一实例，模块实例用来帮模块内代码共享数据和组件。】

【使用模块

要在应用中使用模块，只需要将模块加入到应用主体配置的yii\base\Application::modules属性的列表中， 如下代码的应用主体配置 使用 forum 模块:

[
    'modules' => [
        'forum' => [
            'class' => 'app\modules\forum\Module',
            // ... 模块其他配置 ...
        ],
    ],
]】

【过滤器是 控制器 动作 执行之前或之后执行的对象。

过滤器可包含 beforeAction预过滤（过滤逻辑在动作之前） 或 afterAction后过滤（过滤逻辑在动作之后）， 也可同时包含两者。


创建过滤器

继承 yii\base\ActionFilter 类并覆盖 yii\base\ActionFilter::beforeAction() 和/或 yii\base\ActionFilter::afterAction() 方法来创建动作的过滤器，前者在动作执行之前执行，后者在动作执行之后执行。


Yii提供了一组常用过滤器，在yii\filters命名空间下
】

【也可在模块或应用主体 中申明过滤器，可以在控制器类中覆盖它的 yii\base\Controller::behaviors() 方法来申明过滤器】


OAuth 2 来认证一个用户

【yii框架默认数据库的访问方式是PDO数据访问层DAO】

【数据库访问 (DAO)

Yii 包含了一个建立在 PHP PDO 之上的数据访问层 (DAO)。DAO为不同的数据库提供了一套统一的API。 其中`ActiveRecord` 提供了数据库与模型(MVC 中的 M,Model) 的交互，`QueryBuilder` 用于创建动态的查询语句。 DAO提供了简单高效的SQL查询，可以用在与数据库交互的各个地方.】

【数据库查询：
$db = Yii::$app->db;

$rows =$db->createCommand('SELECT * FROM user LIMIT 10')->queryAll();
$rows2=$db->createCommand("UPDATE user SET username='demo' WHERE id=1")->execute();


】

【支持事务，嵌套事务】


【createCommand()属于yii\db\Connection.php类方法】

【模块--$layouts设置为布局名，不需要添加路径，默认layouts文件夹，通过modules文件重写getViewPath（）可改变路径】

【控制器修改布局文件--例如：
class PostController extends Controller
{
    public $layout = 'post';//默认为main
    
    // ...
}】

【yii2-timepicker组件需要php开启extension=php_openssl.dll;】

【yii.js所在位置？yii/assets/下】

【window 一般情况都会有权限读写，在 linux 和 mac 系统下，需要注意运行 php 的用户，有没有权限读写上传目录。】

【控制器部署

可通过配置 yii\base\Application::controllerMap 来强制上述的控制器ID和类名对应， 通常用在使用第三方不能掌控类名的控制器上。

配置 应用配置 中的application configuration，如下所示：

[
    'controllerMap' => [
        // 用类名申明 "account" 控制器
        'account' => 'app\controllers\UserController',

        // 用配置数组申明 "article" 控制器
        'article' => [
            'class' => 'app\controllers\PostController',
            'enableCsrfValidation' => false,
        ],
    ],
]】

【控制器首字母要大写，否则会出错】

【有时候，我们需要处理很大量的数据，这时可能需要用一个数组来存储取到的数据， 从而节省内存。你可以用 asArray() 函数：// 以数组而不是对象形式取回客户信息：
$customers = Customer::find()
    ->asArray()
    ->all();
// $customers 的每个元素都是键值对数组】

【操作数据--插入、更新和删除，模型需要继承ActiveRecord类】

【国际化I18N组件使用到的信息文件语言在yii/messages命名空间下】

【yii\db\ActiveRecord里面的save()方法继承自接口保存记录】
【组件绑定事件on()方法在component类】

【利用 yii\db\connection：createCommand() 方法with a plain SQL query;】
【
yii\db\Command::bindValue(): 绑定值
yii\db\Command::bindValues(): 绑定多个值
yii\db\Command::bindParam(): 绑定参数变量
】

【执行select查询用queryxyz()方法，执行修改、插入操作执行execute()方法】

【执行一系列相关查询用事务--Yii::$app->db->transaction(function($db) {
    $db->createCommand($sql1)->execute();
    $db->createCommand($sql2)->execute();
    // ... executing other SQL statements ...
});】

【如果数据库支持保存点，事务可嵌套，还有数据库支持数据库复制，可配置相应组件实现组从数据库】

【$rows = Yii::$app->db->createCommand('SELECT * FROM user LIMIT 10')->queryAll();

// query against the master
Yii::$app->db->createCommand("UPDATE user SET username='demo' WHERE id=1")->execute();】

【查询构造器--yii\db\Query::filterWhere() 和 yii\db\Query::where() 唯一的不同就在于，前者 将忽略在条件当中的hash format的空值。】

【创建表关联--使用查询构建器---[yii\db\Query::join()|join()]] 是用来指定 SQL 语句当中的 JOIN 子句的。例如，

// ... LEFT JOIN `post` ON `post`.`user_id` = `user`.`id`
$query->join('LEFT JOIN', 'post', 'post.user_id = user.id');

你可以分别调用如下的快捷方法来指定 INNER JOIN, LEFT JOIN 和 RIGHT JOIN。

yii\db\Query::innerJoin()
yii\db\Query::leftJoin()--连接表名
yii\db\Query::rightJoin() 

上述方法除了连接表以外，你还可以连接子查询
】

【数据库查询all()方法用在select子句】

【批处理查询

当需要处理大数据的时候，像 yii\db\Query::all() 这样的方法就不太合适了， 因为它们会把所有数据都读取到内存上。为了保持较低的内存需求， Yii 提供了一个 所谓的批处理查询的支持。】

【查询构建器

查询构建器建立在 Database Access Objects 基础之上，可让你创建 程序化的、DBMS无关的SQL语句。相比于原生的SQL语句，查询构建器可以帮你 写出可读性更强的SQL相关的代码，并生成安全性更强的SQL语句。

使用查询构建器通常包含以下两个步骤：

创建一个 yii\db\Query 对象来代表一条 SELECT SQL 语句的不同子句（例如 SELECT, FROM）。
执行 yii\db\Query 的一个查询方法（例如：all()）从数据库当中检索数据。】

【数据库数据3中访问方式--DAO数据库、查询生成器、活动记录】

【在 Yii 中使用表单的主要方式是通过 yii\widgets\ActiveForm。如果是基于 模型的表单应首选这种方式。】

【 yii\helpers\Html中有一些实用的 方法用于添加按钮和帮助文本。】

【yii\widgets\ActiveForm::field() 方法在调用时，会返回一个 yii\widgets\ActiveField 的实例。 直接输出该方法时，结果是一个普通的（文本）输入。要自定义输出，可以附加上 yii\widgets\ActiveField 的其它方法来一起调用】

【安全属性---safe验证器
public function rules()
{
    return [
        [['title', 'description'], 'safe'],
    ];
}】
【可以使用 ActiveForm 的 dropDownList() 方法来创建一个下拉列表，还有，The yii\widgets\Pjax widget allows you to update a certain section of a page instead of reloading the entire page.】

【用到use yii的地方，yii可用\yii代替】

yii/web/user---User is the class for the `user` application component that manages the user authentication status

【要让 validate() 方法起作用，你需要声明与需验证模型特性相关的验证规则。 】

【验证事件

当调用 yii\base\Model::validate() 方法的过程里，它同时会调用两个特殊的方法beforeValidate()和afterValidate()】

【表单验证器分核心验证器（许多核心验证器都支持开箱即用的客户端验证）和行内验证和独立验证、条件式验证、数据预处理、处理空输入、自定义验证器】

【自己实现客户端验证

要穿件一个支持客户端验证的验证器，你需要实现 yii\validators\Validator::clientValidateAttribute() 方法， 用于返回一段用于运行客户端验证的 JavaScript 代码。】

【ajax验证--Deferred Validation和AJAX Validation】

【yii/db/connection::createcommand()方法、execute（）、queryone()、queryall()等queryxyz方法在DAO操作中使用】

【查询数据

AR 提供了两种方法来构建 DB 查询并向 AR 实例里填充数据：

yii\db\ActiveRecord::find()
yii\db\ActiveRecord::findBySql()】

【有两个快捷方法：findOne 和 findAll() 用来返回一个或者一组ActiveRecord实例。前者返回第一个匹配到的实例，后者返回所有。 】

【// 插入新客户的记录
$customer = new Customer();
$customer->name = 'James';
$customer->email = 'james@example.com';
$customer->save();  // 等同于 $customer->insert();

// 更新现有客户记录
$customer = Customer::findOne($id);
$customer->email = 'james@example.com';
$customer->save();  // 等同于 $customer->update();】

【save() 方法会调用 insert() 和 update() 中的一个， 用哪个取决于当前 AR 对象是不是新对象（在函数内部，他会检查 yii\db\ActiveRecord::isNewRecord 的值）。 若 AR 对象是由 new 操作符 初始化出来的，save() 方法会在表里插入一条数据； 如果一个 AR 是由 find() 方法获取来的， 则 save() 会更新表里的对应行记录。】



【文件上传

在Yii里上传文件通常使用yii\web\UploadedFile类， 它把每个上传的文件封装成 UploadedFile 对象。】

model里面的load（）方法执行块赋值

load()将表单数据赋值给模型属性，save()将模型属性值保存进数据库。

yii/web/user--User is the class for the `user` application component that manages the user authentication status.

控制器gohome()与goback()


【判断请求是否提交--Yii::$app->request->isPost】


【防止使用URL访问--使用存取控制过滤器
（ACF）是一种通过 yii\filters\AccessControl 类来实现的简单授权方法， 非常适用于仅需要简单的存取控制的应用。正如其名称所指，ACF 是一个种行动（action）过滤器 filter，可在控制器或者模块中使用。当一个用户请求一个 action 时， ACF会检查 yii\filters\AccessControl::rules 列表，判断该用户是否允许执 行所请求的action。（译者注： action 在本文中视情况翻译为行动、操作、方法等）】

【模型validate（)验证触发rule规则（）】

【注意：不要混淆 user 认证类和用户组件 yii\web\User。前者是实现 认证逻辑的类，通常用关联了 持久性存储的用户信息的AR模型 Active Record 实现。后者是负责管理用户认证状态的 应用组件。2者相互配合】

模型和控制器都可添加--行为方法behaviors（），控制器添加的为过滤器功能，模型为附属功能。

【yii\filters\AccessRule::verbs：指定该规则用于匹配哪种请求方法（例如GET，POST）。 这里的匹配大小写不敏感。】

【授权是验证用户是否有足够权限做一些事情的过程。Yii 提供了两种方法来管理授权：

访问控制过滤器（Access Control Filter，简称 ACF）
基于角色的访问控制（Role-Based Access Control，简称 RBAC）】

【认证--Yii提供了一个认证框架，它连接了不同的组件以支持登录。欲使用这个框架， 你主要需要做以下工作：

1.设置用户组件 yii\web\User ;
2.创建一个类实现 yii\web\IdentityInterface 接口。

当然你还要在web应用组件配置如下：
【'user' => [
            'identityClass' => 'app\modules\models\Login',
            'enableAutoLogin' => true,
            'loginUrl' => ['article/login/deny'],//认证不通过转向地址
        ]】



登录用户：

// 使用指定用户名获取用户身份实例。
// 请注意，如果需要的话您可能要检验密码
$identity = User::findOne(['username' => $username]);

// 登录用户
Yii::$app->user->login($identity);

//获取用户名
Yii::$app->user->identity->username：通过identity可获取表数据
――――――――――――――――――――――――――――――――
调用过login（）方法后，如下值才不为空

/ 当前用户的身份实例。未认证用户则为 Null 。
$identity = Yii::$app->user->identity;

// 当前用户的ID。 未认证用户则为 Null 。
$id = Yii::$app->user->id;

// 判断当前用户是否是游客（未认证的）
$isGuest = Yii::$app->user->isGuest;

】

【yii/helpers/url里面的to()和toRoute()用法区别：

\yii\helpers\Url::to(['default/home'])注意：参数为中括号
\yii\helpers\Url::toRoute('default/home')
】

【数据库迁移migrate---yii migtate  迁移工具将会自动在数据库当中创建表等内容，主要用迁移类，在类定义up()定义内容和down()方法取消内容，来操作数据库

使用如下命令来创建一个新的迁移：

yii migrate/create <name>注意create包括，不是可选。

如上命令将会在 @app/migrations 目录下创建一个新的名为 <name>的 PHP 类文件。
】

【非安全属性

如上所述，yii\base\Model::scenarios() 方法提供两个用处：定义哪些属性应被验证，定义哪些属性安全。 在某些情况下，你可能想验证一个属性但不想让他是安全的， 可在scenarios()方法中属性名加一个惊叹号 !】

【规则On指定场景的规则称之为 active rule活动规则】

【块赋值---$model = new \app\models\ContactForm;
$model->attributes = \Yii::$app->request->post('ContactForm');】

【filter验证器--yii\validators\FilterValidator

[
    // trim 掉 "username" 和 "email" 输入
    [['username', 'email'], 'filter', 'filter' => 'trim', 'skipOnArray' => true],

    // 标准化 "phone" 输入
    ['phone', 'filter', 'filter' => function ($value) {
        // 在此处标准化输入的电话号码
        return $value;
    }],
]
该验证器并不进行数据验证。而是，给输入值应用一个滤镜， 并在检验过程之后把它赋值回特性变量。】

【yii\validators\RegularExpressionValidator

[
    // 检查 "username" 是否由字母开头，且只包含单词字符
    ['username', 'match', 'pattern' => '/^[a-z]\w*$/i']
]
该验证器检查输入值是否匹配指定正则表达式。】

【检测数据表用户名是否已存在---yii\validators\UniqueValidator

[
    // a1 需要在 "a1" 特性所代表的字段内唯一
    ['a1', 'unique'],

    // a1 需要唯一，但检验的是 a1 的值在字段 a2 中的唯一性
    ['a1', 'unique', 'targetAttribute' => 'a2'],

    // a1 和 a2 的组合需要唯一，且它们都能收到错误提示
    [['a1', 'a2'], 'unique', 'targetAttribute' => ['a1', 'a2']],

    // a1 和 a2 的组合需要唯一，只有 a1 能接收错误提示
    ['a1', 'unique', 'targetAttribute' => ['a1', 'a2']],

    // 通过同时在 a2 和 a3 字段中检查 a2 和 a3 的值来确定 a1 的唯一性
    ['a1', 'unique', 'targetAttribute' => ['a2', 'a1' => 'a3']],
]
该验证器检查输入值是否在某表字段中唯一。 它只对活动记录类型的模型类特性起作用， 能支持对一个或多过字段的验证。】

【为应用添加时区yii\base\Application::timeZone

该属性提供一种方式修改PHP运行环境中的默认时区，配置该属性本质上就是调用PHP函数 date_default_timezone_set()， 例如：

[
    'timeZone' => 'America/Los_Angeles',
]】

【从模型获取所有数据---$model::find()->asArray()->all()】

【yii\helpers\ArrayHelper::map()---Builds a map (key-value pairs) from a multidimensional array or an array of objects.

例如：

$form->field($model, 'username')->dropDownList(ArrayHelper::map($data,'id', 'customer_name'));
2.1、dropDownList           --->     yii2.0  下拉列表的方法
2.2、ArrayHelper::map()     --->     构建一个(key => value) 的一维或多维数组
2.3.1、 $data               --->     数据源--应该是一个二维数据
2.3.2、 id                  --->     option 的 value 值
2.3.3、 customer_name       --->     option 标签的 值


】

【 yii\helpers\Html::encode()将html转化为实体，a()Generates a hyperlink tag.】

【yii\widgets\ActiveForm---builds an interactive HTML form for one or multiple data models】

【如果在你的应用中应用了不止一个数据库，且你需要给你的 AR 类使用不同的数据库链接（DB connection） ，你可以覆盖掉 yii\db\ActiveRecord::getDb() 方法：

class Customer extends ActiveRecord
{
    // ...

    public static function getDb()
    {
        return \Yii::$app->db2;  // 使用名为 "db2" 的应用组件
    }
}】

【当你调用 save()、insert()、update() 这三个方法时，会自动调用yii\base\Model::validate()方法。如果验证失败，数据将不会保存进数据库。】

【AR读取默认值--读取默认值

你的表列也许定义了默认值。有时候，你可能需要在使用web表单的时候给AR预设一些值。如果你需要这样做，可以在显示表单内容前通过调用loadDefaultValues()方法来实现：

$customer = new Customer();
$customer->loadDefaultValues();
// ... 渲染 $customer 的 HTML 表单 ...】

【模型使用 yii\base\Model::scenario 属性保持使用场景的跟踪， 默认情况下，模型支持一个名为 default 的场景：
 如下展示两种设置场景的方法:

// 场景作为属性来设置
$model = new User;
$model->scenario = 'login';

// 场景通过构造初始化配置来设置
$model = new User(['scenario' => 'login']);

】

【rule--可添加message属性：提示出错信息】

【yii\base\Model::toArray() 方法在arrayabletrait.php】

【注意render传参格式---searchModel没有$,值有$
    return $this->render('index', [
            'searchModel' => $t,
            'dataProvider' => $dataProvider,
        ]);

】

【$post = \app\models\Post::findOne(100);
$array = $post->attributes;或者$array = $post->toArray([直接加入许你选择哪些称之为字段的数据项放入到结果数组中]);等效于$model->find()-one()】

【yii::$app->request->post()和yii::$app->request->get()】

【控制器redirect（$url）返回指向调用yii\web\Response::redirect().$url可为string|数组，当为数组时，可传参，传递方式为get,接收用yii::$app->request->get()】


【控制器
goHome()方法：回到主页；goBack()返回最后访问页面，goBack(string)加参数也可实现重定向】

【覆盖模型fields()方法使用unset()可实现过滤掉不显示的表属性，例如：

public function fields()
{
    $fields = parent::fields();

    // 去掉一些包含敏感信息的字段
    unset($fields['auth_key'], $fields['password_hash'], $fields['password_reset_token']);

    return $fields;
}
】

【字段是模型通过调用yii\base\Model::toArray() 生成的数组的单元名。

fields()方法/extraFields()方法成功调用,需要搭配toArray（）方法；

fields() 方法定义的字段是默认字段， 表示toArray()方法默认会返回这些字段。

extraFields()方法定义额外可用字段（操作当前模型字段使用function(){return ...}），通过toArray()方法指定$expand参数来返回这些额外可用字段。

 例如如下代码会返回fields()方法定义的所有字段 和extraFields()方法定义的prettyName and fullAddress字段。

$array = $model->toArray([], ['prettyName', 'fullAddress']);
】

【模型策略：定义可被多个 应用主体 或 模块 共享的模型基类集合】

【      $model2=new Category();
        $t=$model2->findone(6)->toArray([],['arc1']);】

【控制器默认存在属性 public $layout;定义方法render()使用布局文件，例如：
$this->layout='main3.php';】

【$model=$model2->find()->one()->toArray()注意one()和toArray()前后顺序,


】

【访问列数据
使用以下语法读取列的值：

// "id" 和 "mail" 是 $customer 对象所关联的数据表的对应字段名
$id = $customer->id;
$email = $customer->email;

** $customer为查询的结果集对象，没有toArray()转化为数组**
】

【ar findOne()方法参数可为数组，findOne([ 'id' => 1,...])】

【服务定位器用来配置组件】

【可在控制器behaviors()方法配置过滤组件】

【控制器render()方法传值，并没有发起post/get请求,而是渲染加载页面】

【activerecord批量获取数据：

例如：

// 一次提取 10 个客户信息
foreach (Customer::find()->batch(10) as $customers) {
    // $customers 是 10 个或更少的客户对象的数组
}
// 一次提取 10 个客户并一个一个地遍历处理
foreach (Customer::find()->each(10) as $customer) {
    // $customer 是一个 ”Customer“ 对象
}
// 贪婪加载模式的批处理查询
foreach (Customer::find()->with('orders')->each() as $customer) {
}


】

【toArray()方法在yii\base\Model里面的use arrayableTrait, asArray()方法在yii\db\ActiveQuery】

【模型是代表业务数据、规则和逻辑的中心地方，通常在很多地方重用， 在一个设计良好的应用中， 模型通常比控制器代码多】

【理解Model类与ActiveRecord类的区别：
Model类主要用在获取表单数据上，ActiveRcord类主要用在获取数据库表内容上。
模型是 MVC 模式中的一部分， 是代表业务数据、规则和逻辑的对象。
】

【注意模型特指Model类--模型使用 yii\base\Model::scenario 属性保持使用场景的跟踪】

【attributes属性获取模型modle属性数--组键值对
 $t=new \app\modules\models\CaseModel;
 $t->attributes;

】

【ActiveRecord类：

find()/findBysql()两个方法都会返回 yii\db\ActiveQuery 实例;
findOne()和 findAll() 用来返回一个或者一组ActiveRecord实例

find()不需要与findOne()需要加参数,find()->select([参数])限制获取哪些字段。

模型的toArray()可以用在ActiveRecord类的findOne()/findAll()方法后面，不能用在find(),好像有时候不能用
】

todo---翻译：一切/备忘录

【// 所有客户的age（年龄）字段加1：
Customer::updateAllCounters(['age' => 1]);

updateAllCounters（自增量，表属性）函数用法；例如：
updateAllCounters(['arc_count' => 1],['cat_name'=>$t2]){...}
】

【model的fields()方法与extraFields()可以定义在ActiveRecord类中
最后需要调用toArray()方法。
――――――――――――――――――――――――――――――――――――
默认情况下，字段名对应属性名，但是你可以通过覆盖 yii\base\Model::fields() 和/或 yii\base\Model::extraFields() 方法来改变这种行为， 两个方法都返回一个字段定义列表，fields() 方法定义的字段是默认字段， 表示toArray()方法默认会返回这些字段。 extraFields()方法定义额外可用字段，通过toArray()方法指定$expand参数来返回这些额外可用字段。 例如如下代码会返回fields()方法定义的所有字段 和extraFields()方法定义的prettyName and fullAddress字段。

$array = $model->toArray([], ['prettyName', 'fullAddress']);
可通过覆盖 fields() 来增加、删除、重命名和重定义字段， fields() 方法返回值应为数组， 数组的键为字段名，数组的值为对应的可为属性名或匿名函数返回的字段定义对应的值。 特使情况下，如果字段名和属性定义名相同，可以省略数组键， 例如：

// 明确列出每个字段，特别用于你想确保数据表或模型
// 属性改变不会导致你的字段改变(保证后端的API兼容)。
public function fields()
{
    return [
        // 字段名和属性名相同
        'id',

        // 字段名为 "email"，对应属性名为 "email_address"
        'email' => 'email_address',

        // 字段名为 "name", 值通过PHP代码返回
        'name' => function () {
            return $this->first_name . ' ' . $this->last_name;
        },
    ];
}

// 过滤掉一些字段，特别用于你想
// 继承父类实现并不想用一些敏感字段
public function fields()
{
    $fields = parent::fields();

    // 去掉一些包含敏感信息的字段
    unset($fields['auth_key'], $fields['password_hash'], $fields['password_reset_token']);

    return $fields;
}

――――――――――――――――――――――――

】

【AR实例方法：
yii\db\ActiveRecord::save()
yii\db\ActiveRecord::insert()
yii\db\ActiveRecord::update()
yii\db\ActiveRecord::delete()

ＡＲ静态方法：

yii\db\ActiveRecord::updateCounters()
yii\db\ActiveRecord::updateAll()
yii\db\ActiveRecord::updateAllCounters()
yii\db\ActiveRecord::deleteAll()
】

【$model->isNewRecord 判断是否是新记录】

【整形规则rule--关键词integer】

【Activeform里面的field($model, 'username')方法，输出既有文本框，可不加textinput()】

【为了使表单模型数据每项保存成功，需在rule()定义(它的)相关属性验证规则】

【rule()规则可在model和activerecord类中定义】

【注销现有结果集：unset($customer->orders);】

【延迟加载和即时加载，通常用在表关联上】

【定义表关联--在模型中定义hasone()或者hasmany()关系，有时，两个表通过中间表关联，定义这样的关联关系，在上述关系后面，可以通过调用 yii\db\ActiveQuery::via() 方法或 yii\db\ActiveQuery::viaTable() 方法来定制 yii\db\ActiveQuery 对象 。】

【查询大量数据时---可以通过调用 yii\db\ActiveQuery::with() 方法使用即时加载】

【逆关系

关联关系通常成对定义，在实际当中，并不很常用】

贪婪加载即即时加载

【默认 yii\db\ActiveQuery::joinWith() 使用左连接来连接关联表；joinwith()关联默认使用即时加载】

【hasone()与hasmany()返回ActiveQuery对象】

【yii\db\ActiveQuery::joinWith() 可以重用已定义关系（即在model类里定义的getter(){$this-hasone()/$this-hasmany()方法}）并调用】

【有时连接两个表时，需要在关联查询的 ON 部分指定额外条件。 这可以通过调用 yii\db\ActiveQuery::onCondition() 方法实现：

class User extends ActiveRecord
{
    public function getBooks()
    {
        return $this->hasMany(Item::className(), ['owner_id' => 'id'])->onCondition(['category_id' => 1]);
    }
}
在上面， yii\db\ActiveRecord::hasMany() 方法回传了一个 yii\db\ActiveQuery 对象， 当你用 yii\db\ActiveQuery::joinWith() 执行一条查询时，取决于正被调用的是哪个 yii\db\ActiveQuery::onCondition()， 返回 category_id 为 1 的 items

当你用 yii\db\ActiveQuery::joinWith() 进行一次查询时，“on-condition”条件会被放置在相应查询语句的 ON 部分， 如：

// SELECT user.* FROM user LEFT JOIN item ON item.owner_id=user.id AND category_id=1
// SELECT * FROM item WHERE owner_id IN (...) AND category_id=1
$users = User::find()->joinWith('books')->all();】


【关联表操作--作用:使一个对象拥有另一个对象】

【关联表操作

AR 提供了下面两个方法用来建立和解除两个关联对象之间的关系：

yii\db\ActiveRecord::link()
yii\db\ActiveRecord::unlink()
例如，给定一个customer和order对象，我们可以通过下面的代码使得customer对象拥有order对象：

$customer = Customer::findOne(1);
$order = new Order();
$order->subtotal = 100;
$customer->link('orders', $order);
yii\db\ActiveRecord::link() 调用上述将设置 customer_id 的顺序是 $customer 的主键值，然后调用 yii\db\ActiveRecord::save() 要将顺序保存到数据库中。】

【where 还有 yii\db\ActiveQuery::andWhere() 和 yii\db\ActiveQuery::orWhere()】

【为实现查询方法范围重用--定义作用域，它可在关联里、关联查询里使用。

步骤：1、首先，创建一个类继承activeQuery，然后在CommentQuery类中定义一个active()的方法为作用域.
      2、其次，覆盖yii\db\ActiveRecord::find() 方法使其返回自定义的查询对象而不是常规的yii\db\ActiveQuery。

例如： public static function find()
    {
        return new CommentQuery(get_called_class());
    }


】

【默认作用域---yii\db\ActiveRecord::find()方法来定义一个默认作用域】

【当执行几个相关联的数据库操作的时候，就要用到“事务操作”。

开发者可以通过重写yii\db\ActiveRecord::save()方法然后在控制器里使用事务操作】

【$this-getScenario()返回模型使用的场景】

【被污染属性---一个属性是否认定为被污染取决于它的值自从最后一次从数据库加载或者最近一次保存到数据库后到现在是否被修改过】

【gii生成模块方法--Module Class选项-例如：app\modulesfrontweb\frontweb（frontweb为模块文件名）】

【YII::t('app',)第一个参数app是一个目录】

【模块创建好后，为控制器添加统一布局文件，在创建的模块文件中配置】

【绑定参数格式--- :last_name 参数绑定了 字符串 'Smith'】

查询构建器方法，例如select()

【组件Widget.php文件在yii\base命名空间下】

-----------------------以下为查询构建器----------------------------------------
【select()使用：
$query->select(['id', 'email']);

// 等同于：

$query->select('id, email');

如果使用数组格式来指定字段，你可以使用数组的键值来表示字段的别名。 例如，上面的代码可以被重写为如下形式：

$query->select(['user_id' => 'user.id', 'email']);

除了字段名称以外，你还可以选择数据库的表达式，例如：

$query->select(["CONCAT(first_name, ' ', last_name) AS full_name", 'email']); 


你应该调用 yii\db\Query::distinct() 方法来去除重复行，如下所示：

// SELECT DISTINCT `user_id` ...
$query->select('user_id')->distinct();
你可以调用 yii\db\Query::addSelect() 方法来选取附加字段，例如：

$query->select(['id', 'username'])
    ->addSelect(['email']);
】

【from()---你可以通过字符串或者数组的形式来定义被查询的表名称。就像你写原生的 SQL 语句一样， 表名称里面可包含数据库前缀，以及/或者表别名。例如：

$query->from(['public.user u', 'public.post p']);注释：public为数据库名


除了表名以外，你还可以从子查询中再次查询，这里的子查询是由 yii\db\Query 创建的对象。 例如：

$subQuery = (new Query())->select('id')->from('user')->where('status=1');

// SELECT * FROM (SELECT `id` FROM `user` WHERE status=1) u 
$query->from(['u' => $subQuery]);
】

【yii\db\Query::where() 方法定义了 SQL 语句当中的 WHERE 子句。 你可以使用如下三种格式来定义 WHERE 条件：

字符串格式，例如：'status=1'
哈希格式，例如： ['status' => 1, 'type' => 2]
操作符格式，例如：['like', 'name', 'test']


附加条件

你可以使用 yii\db\Query::andWhere() 或者 yii\db\Query::orWhere() 在原有条件的基础上 附加额外的条件。你可以多次调用这些方法来分别追加不同的条件。


过滤条件－－实现搜索表单

当 WHERE 条件来自于用户的输入时，你通常需要忽略用户输入的空值。 例如，在一个可以通过用户名或者邮箱搜索的表单当中，用户名或者邮箱 输入框没有输入任何东西，这种情况下你想要忽略掉对应的搜索条件， 那么你就可以使用 yii\db\Query::filterWhere() 方法来实现这个目的：

// $username 和 $email 来自于用户的输入
$query->filterWhere([
    'username' => $username,
    'email' => $email,		
]);
yii\db\Query::filterWhere() 和 yii\db\Query::where() 唯一的不同就在于，前者 将忽略在条件当中的hash format的空值。所以如果 $email 为空而 $username 不为空，那么上面的代码最终将生产如下 SQL ...WHERE username=:username。
】

【防止ＳＱＬ注入攻击－－－当使用参数绑定的时候，你可以调用 yii\db\Query::params() 或者 yii\db\Query::addParams() 方法 来分别绑定不同的参数。

$query->where('status=:status')
    ->addParams([':status' => $status]);】

【$query->andFilterCompare('value', '<=100');与where(操作符格式)相似】

**yii\db\Query::orderBy() 方法是用来指定 SQL 语句当中的 ORDER BY 子句的**

【你可以调用 
[yii\db\Query::addOrderBy()|addOrderBy()]] 来为 ORDER BY 片断添加额外的子句。 例如，

$query->orderBy('id ASC')
    ->addOrderBy('name DESC');】

【yii\db\Query::groupBy() 方法是用来指定 SQL 语句当中的 GROUP BY 片断的。】

【yii\db\Query::having() 方法是用来指定 SQL 语句当中的 HAVING 子句。它带有一个条件， 和 where() 中指定条件的方法一样。】

【你可以调用 yii\db\Query::andHaving() 或者 yii\db\Query::orHaving() 方法来为 HAVING 子句追加额外的条件】

【yii\db\Query::limit() 和 yii\db\Query::offset() 是用来指定 SQL 语句当中 的 LIMIT 和 OFFSET 子句的。例如，

// ... LIMIT 10 OFFSET 20
$query->limit(10)->offset(20);】

【[yii\db\Query::join()|join()]] 是用来指定 SQL 语句当中的 JOIN 子句的】
【你可以分别调用如下的快捷方法来指定 INNER JOIN, LEFT JOIN 和 RIGHT JOIN。

yii\db\Query::innerJoin()
【yii\db\Query::leftJoin()
例如：$query->leftJoin('post', 'post.user_id = user.id');】
yii\db\Query::rightJoin()】

【以下方法用于查询构造器--查询方法

yii\db\Query 提供了一整套的用于不同查询目的的方法。

yii\db\Query::all(): 将返回一个由行组成的数组，每一行是一个由名称和值构成的关联数组（译者注：省略键的数组称为索引数组）。
yii\db\Query::one(): 返回结果集的第一行。
yii\db\Query::column(): 返回结果集的第一列。
yii\db\Query::scalar(): 返回结果集的第一行第一列的标量值。
yii\db\Query::exists(): 返回一个表示该查询是否包结果集的值。
yii\db\Query::count(): 返回 COUNT 查询的结果。
其它集合查询方法: 包括 yii\db\Query::sum(), yii\db\Query::average(), yii\db\Query::max(), yii\db\Query::min() 等. $q 是一个必选参数， 既可以是一个字段名称，又可以是一个 DB 表达式。

所有的这些查询方法都有一个可选的参数 $db, 该参数指代的是 yii\db\Connection， 执行一个 DB 查询时会用到。
】

【打印sql---

有时候，你也许想要测试或者使用一个由 yii\db\Query 对象创建的 SQL 语句。 你可以使用以下的代码来达到目的：

$command = (new \yii\db\Query())
    ->select(['id', 'email'])
    ->from('user')
    ->where(['last_name' => 'Smith'])
    ->limit(10)
    ->createCommand();
    
// 打印 SQL 语句
echo $command->sql;
// 打印被绑定的参数
print_r($command->params);

// 返回查询结果的所有行
$rows = $command->queryAll();

】
【 yii\db\Query::indexBy() 方法为查询结果指定了索引字段】

【批处理查询

当需要处理大数据的时候，像 yii\db\Query::all() 这样的方法就不太合适了， 因为它们会把所有数据都读取到内存上。为了保持较低的内存需求， Yii 提供了一个 所谓的批处理查询的支持。

批处理查询的用法如下：

use yii\db\Query;

$query = (new Query())
    ->from('user')
    ->orderBy('id');

foreach ($query->batch() as $users) {
    // $users 是一个包含100条或小于100条用户表数据的数组
}

// or if you want to iterate the row one by one
foreach ($query->each() as $user) {
    // $user 指代的是用户表当中的其中一行数据
}

】

【yii\db\Query::union() 方法是用来指定 SQL 语句当中的 UNION 子句的。你可以通过多次调用 yii\db\Query::union() 方法来追加更多的 UNION 子句。】

--------------------------查询构建器内容结束------------------------------
【国际化使用：
1.确保安装intl组件
2.web.php配置：

目标语言  'language'=>'zh-CN',

component组件配置i18n组件
【'i18n' => [
            'translations' => [
                'app*' => [
                    'class' => 'yii\i18n\PhpMessageSource',
//                'basePath' => '@app/messages',
                    //   'sourceLanguage' => 'en',
                    'fileMap' => [
                        'app' => 'app.php',
                        'app/error' => 'error.php',
                    ],
                ],
            ],
        ],】

3.建立语言包文件夹，默认'basePath' => '@app/messages',在网站根目录建立messages文件夹，以目标语言名建立子文件夹，在里面建立app.php对应的翻译信息（参照yii/messages下语言包文件）

】


--------------------数据库访问DAO---------------------------------

【数据库访问--queryxyz()执行查询，execute()执行更新操作】

【注意3种数据库访问，各种方法的使用范围，不要混淆，queryxyz类函数用在数据库访问（DAO）】

【yii\web\Request $queryParams属性	--array	The request GET parameter values.	】

【Tip: Sometimes you may want to execute some queries right after the database connection is established to initialize some environment variables (e.g., to set the timezone or character set). You can do so by registering an event handler for the yii\db\Connection::EVENT_AFTER_OPEN event of the database connection. You may register the handler directly in the application configuration like so:

'db' => [
    // ...
    'on afterOpen' => function($event) {
        // $event->sender refers to the DB connection
        $event->sender->createCommand("SET time_zone = 'UTC'")->execute();
    }
],】

【服务定位器模式和依赖注入模式都是控制反转（IoC）模式的实现。】

【可以在 应用配置 中修改默认控制器默认为default控制器，如下所示：

[
    'defaultRoute' => 'dedault',
]】

【node_modules文件夹为添加的下载node包文件】

【发现GridView组件显示表属性时，有些属性没有排序框--需在searchmodel里面rule()定义表属性规则，不要遗漏。否则，该属性没有搜索框】

【控制器behaviors()--主要用于过滤，在所有与actions（）动作之前执行，而actions(）方法--为调用方法时总被调用的方法。】

【Yii提供两种授权方法： 存取控制过滤器（ACF）和基于角色的存取控制（RBAC）。

存取控制过滤：

public function behaviors()
    {
        return [
            'access' => [
                'class' => AccessControl::className(),
                'only' => ['index','home'],
                'rules' => [
                    // 允许认证用户
                    [
                        'allow' => true,
                        'roles' => ['@'],

                    ],
                    // 默认禁止其他用户
                ],
            ],
        ];
    }


】

【urlManager组件负责处理网页请求路由到对应的控制器。

实现URL美化：
 'urlManager' => [
            'enablePrettyUrl' => true,
            'showScriptName' => false,
            'rules' => [
            ],
        ],

】

【Yii::setAlias('@example', 'http://example.com/');登记路径别名】

【数组赋值方式，在文件中return数组-- 'extensions' => require(__DIR__ . '/../vendor/yiisoft/extensions.php')】

【根别名通常在引导阶段定义。比如你可以在 入口脚本里调用 Yii::setAlias()。为 了方便起见，应用提供了一个名为 aliases的 可写属性，你可以在应用配置中设置它，就像这样：

return [
    // ...
    'aliases' => [
        '@foo' => '/path/to/foo',
        '@bar' => 'http://www.example.com',
    ],
];】

【高级模板已经定义@frontend和@backend

在高级应用模版里，每一逻辑层级会使用他自己的根别名。 比如，前端层会使用 @frontend 而后端层会使用 @backend。 因此，你可以把前端的类放在 frontend 命名空间，而后端的类放在 backend。 这样这些类就可以被 Yii 自动加载了。

】

【在应用web.php 里面的component配置如下，实现404页面：

 /**
         *404页面定义设置
         */
        'errorHandler' => [
//            'errorAction' => 'site/error',//默认错误页
            'errorAction' => 'article/redirect/index', 
           //'errorAction'路径：模块/控制器/操作
        ],

】

【我理解的，依赖注入--实现类及对象参数配置，服务定位器--实现加载对象实例，2者配合
】

【其他地方调用组件实例--使用服务定位器】

类构造器参数的类型提示

【当调用 Yii::createObject() 时，此方法实际上会调用这个容器的 yii\di\Container::get() 方法创建新对象。】

【类映射表（Class Map）classes.php

Yii 类自动加载器支持类映射表功能，该功能会建立一个从类的名字到类文件路径的映射。 当自动加载器加载一个文件时，他首先检查映射表里有没有该类。 如果有，对应的文件路径就直接加载了，省掉了进一步的检查。 这让类的自动加载变得超级快。事实上所有的 Yii 核心类都是这样加载的。

你可以用 Yii::$classMap 方法向映射表中添加类，

Yii::$classMap['foo\bar\MyClass'] = 'path/to/MyClass.php';
别名可以被用于指定类文件的路径。 你应该在引导启动的过程中设置类映射表，这样映射表就可以在你使用具体类之前就准备好。】

【依赖注入容器Container--实现注册类依赖关系，调用依赖关系，实例化类】

【Yii 在依赖住入（DI）容器之上实现了它的服务定位器。当一个服务定位器尝试创建一个新的对象实例时，它会把调用转发到 DI 容器。】

【Yii::createObject（）---
     * Creates a new object using the given configuration.
     *
     * You may view this method as an enhanced version of the `new` operator.
     * The method supports creating an object based on a class name, a        configuration array or
     * an anonymous function.


】

【关联即时加载---with()方法在ActiveQuery.php中】

【关联关系定义--一种简单的hasone()方式，一种是通过中间表方式，再一种是join类型关联】

【return $this->hasOne(Login::className(), ['id' => 'user_id']);

说明：id属于数据库模型Login属性，user_id属于当前定义关系的数据库模型属性。

】

【建立getOrder(){}关联关系后，获取关联数据和获取组件属性一样简单， 执行以下相应getter方法即可：

// 取得客户的订单
$customer = Customer::findOne(1);
$orders = $customer->orders; // $orders 是 Order 对象数组

注：需在相应的活动记录类，添加public orders属性。
】

【使用innerjoin（）或者左右链接，添加第二个参数可替换定义hasxyx(）关系。】

【关联查询查询数据---如：

$model=new Login();
$date=$model->find()->with('article')->asArray()->one();

$date返回的对象是数组，其中关联的表返回的是一个多维数组。

】

【该方式只获取article表数据，返回关联关系id=23的数组--$date=Login::findOne(['id'=>23])->getArticle()->asArray()->all();】

【关联代码写法--例如
Login::find()->orderBy('id')->indexBy('id')->innerJoinWith('article')->asArray()->all();

或者
$date = Login::find()->where('user_id=23')->innerJoinWith('article')->asArray()->all();

】

【关联限制添加：where()或在hasxyz()关系定义
 $date2=$model->find()->where('id=29')->with('article')->asArray()->one();
】

【 注意:当用即时加载定制 select() 时，确保连接 到关联模型的列都被包括了，否则，关联模型不会载入。如：

$orders = Order::find()->select(['id', 'amount'])->with('customer')->all();
// $orders[0]->customer 总是空的，使用以下代码解决这个问题：
$orders = Order::find()->select(['id', 'amount', 'customer_id'])->with('customer')->all();】

【使用getLogin()或者join（）使用已定义关联关系】

【joinwith（)方法可加连接条件，使其为内外左右连接】

【有时连接两个表时，需要在关联查询的 ON 部分指定额外条件。 这可以通过调用 yii\db\ActiveQuery::onCondition() 方法实现：

class User extends ActiveRecord
{
    public function getBooks()
    {
        return $this->hasMany(Item::className(), ['owner_id' => 'id'])->onCondition(['category_id' => 1]);
    }
}
在上面， yii\db\ActiveRecord::hasMany() 方法回传了一个 yii\db\ActiveQuery 对象， 当你用 yii\db\ActiveQuery::joinWith() 执行一条查询时，取决于正被调用的是哪个 yii\db\ActiveQuery::onCondition()， 返回 category_id 为 1 的 items】

【关联关系hasone()和hasmany()定义与数据表字段是否主键与外键没有关系，多表查询定义多个hasxyz()关系，使用多个join类型连接】

【关联关系可以单向查询，可以只定义一个，而不是成对】

【中间关联表

有时，两个表通过中间表关联，定义这样的关联关系，先建立中间表，然后可以通过调用 yii\db\ActiveQuery::via() 方法或 yii\db\ActiveQuery::viaTable() 方法来定制 yii\db\ActiveQuery 对象 。一般为viaTable() 建立关系，只在一方模型定义，即可查询到多对多关系数据】

【使用 yii\db\ActiveQuery::joinWith() 可以重用已定义关系并调用 ，而不是使用 yii\db\ActiveQuery::join() 来实现目标。join(参数1，参数2)不使用关联关系，可在参数2定义关联条件，实现关联。

方法 yii\db\ActiveQuery::innerJoinWith() 是访问 INNER JOIN 类型的 yii\db\ActiveQuery::joinWith() 的快捷方式。

例如：$date = Article::find()->innerJoinWith('login','login.id=article.user_id')->asArray()->all()

】

【安装"yiisoft/yii2-smarty": "~2.0.0",会安装另一个smarty扩展】

【html5 placeholder属性，yii添加该属性格式---
 <?= $form->field($model, 'username',['inputOptions'=>['placeholder'=>'输入用户名']]) ?>】

【yii转向方法render()与redirect()】

【Yii::$app->user->identity存储用户表各属性，只能在视图使用。

Yii::$app->user->id存储用户表id属性

判断用户是否已经登录--Yii::$app->user->identity/Yii::$app->user->identity->id
】

【$model->isNewRecord判断是否是新纪录，添加表单中判断按钮文字切换】

【用户登录表--id必须是主键，且主键只能有一个】

【 应用配置表前缀：

return [
    // ...
    'components' => [
        // ...
        'db' => [
            // ...
            'tablePrefix' => 'tbl_',
        ],
    ],
];



 public static function tableName()  
    {  
        return '{{%category}}';  
    }  
使用表前缀，需使用{{%表名}}


】

【选出数据库最大id,对id进行降序排列选出头一个

例如： $this->find()->select('id')->orderBy(['id'=>SORT_DESC])->asArray()->one();
】

【orderBy(['id'=>SORT_DESC])降序】

【yii如何获取插入数据库id】

【$model->save()方法返回逻辑值】

【action='/article/login/logout'中/的含义】

【$model->attributes = \Yii::$app->request->post('ContactForm');表单属性名会与表属性名一一相对应】

【new ActiveDataProvider([
            'query' => $query,
        ])获取ActiveDataProvider对象数据作用同查询记录类获取数据】

【Yii::$app->request->queryParams获取get方式获取的数据】

【gridview组件日期配置---
<?= GridView::widget([
        'dataProvider' => $dataProvider,
        'filterModel' => $searchModel,
        'columns' => [
            ['class' => 'yii\grid\SerialColumn'],

            'id',
            'title',
            [
                'attribute' => 'pub_date',
//                'label'=>'更新时间',
                'value'=>
                    function($model){
                        return  date('Y-m-d',$model->pub_date);   //主要通过此种方式实现
                    },
                'headerOptions' => ['width' => '170'],
            ],
            'img',
            'content:ntext',
             'cat',

            ['class' => 'yii\grid\ActionColumn'],
        ],
    ]); ?>】

设置select option值---  <?= $form->field($model, 'cat')->dropDownList(ArrayHelper::map($cat,'cat_name', 'cat_name'))?>

【更新页面--时间设置数据库存储值，使用value属性：  
  <?= $form->field($model, 'pub_date')->label()->widget(yii\jui\DatePicker::className(),['dateFormat'=>'MM/dd/yyyy','value'=>$model->pub_date])?>】

【rule不等于某值--['cat', 'compare', 'compareValue' => 0, 'operator' => '!=','message'=>'分类不能为空'],】

【Article::find()->orderBy('article.id')->select('cat','cat_name')->innerJoinWith('cat_name')->asArray()->all();可将字段cat_name值赋给cat】

【使用Gridview显示关联数据写法：

1、$query = Article::find()->select("article.*, categeoy.cat_name")->innerJoinWith('cat_name');

        // add conditions that should always apply here

        $dataProvider = new ActiveDataProvider([
            'query' => $query,
        ]);


2、对关联属性cat_name进行排序

 $dataProvider->sort->attributes['cat_name'] = [
            'asc' => ['categeoy.cat_name' => SORT_ASC],
            'desc' => ['categeoy.cat_name' => SORT_DESC],
        ];

3、视图显示Gridview

 <?= GridView::widget([
        'dataProvider' => $dataProvider,
        'filterModel' => $searchModel,
        'columns' => [

            [
                'attribute' => 'cat_name',
                'value' => 'cat_name',
                'label'=>'分类名',   //自定义列名
            ],

            ...
]);
】

【Pjax只在排序时使用ajax】

【yii配置kucha\ueditor扩展百度编辑器---

1.控制器配置：

 public function actions()
    {
        return [
            'upload' => [
                'class' => 'kucha\ueditor\UEditorAction',
                'config' => [
//                    "imageUrlPrefix"  => "http://127.0.0.1",//图片访问路径前缀，本地调试取消添加，有域名可开启
                    "imagePathFormat" => "/upload/image/{yyyy}{mm}{dd}/{time}{rand:6}", //上传保存路径
                    "imageRoot" => Yii::getAlias("@webroot"),//设置图片根目录
//                    "imageRootPath"  => "/static/",//上传保存根路径
                ],
            ]
        ];
    }

2.视图配置：

echo \kucha\ueditor\UEditor::widget(['name' => 'xxxx']);
或者：

echo $form->field($model,'colum')->widget('kucha\ueditor\UEditor',[]);
】

【yii  verdor/bower文件夹存放程序源码--使用Bower包管理器】

【yii提供多种认证和授权手段基于cookie和基于令牌的认证，RBAC等权限控制手段，支持OpenID，OAuth1，OAuth2等。】

【with()参数为关联关系名，

有时候，你想自由的自定义关联查询，延迟加载和即时加载都可以实现，如：

$customer = Customer::findOne(1);
// 延迟加载: SELECT * FROM order WHERE customer_id=1 AND subtotal>100
$orders = $customer->getOrders()->where('subtotal>100')->all();

// 即时加载: SELECT * FROM customer LIMIT 100
//          SELECT * FROM order WHERE customer_id IN (1,2,...) AND subtotal>100
$customers = Customer::find()->limit(100)->with([
    'orders' => function($query) {
        $query->andWhere('subtotal>100');
    },
])->all();
】

【yii使用smarty模板渲染模板可以直接使用render()方法】

【yii\web\Response代表http回复，通过\Yii::$app->response->format = yii\web\Response::FORMAT_JSON;可设置response数据的类型】

【关联尽量使用innerJoinWith()或者是joinWith（），不同点是joinWith（）默认使用左连接，
例如： $data=$query->select(['article.*','cat_name'])->joinWith('cate')->where('article.id=:id')->addParams([':id' => $params])->asArray()->all();】