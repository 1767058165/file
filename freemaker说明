文件后缀为.ftl

与Thymeleaf不同

模板编写为FreeMarker Template Language (FTL)。

模板 + 数据模型 = 输出

为模板准备的数据整体被称作为 数据模型。

模板文件存放在Web服务器上，就像通常存放静态HTML页面那样。当有人来访问这个页面， FreeMarker将会介入执行，然后动态转换模板，用最新的数据内容替换模板中 ${...} 的部分， 之后将结果发送到访问者的Web浏览器中。

【总结：

 数据模型可以被看成是树形结构。

 标量用于存储单一的值。这种类型的值可以是字符串，数字，日期/时间或者是布尔值。

 哈希表是一种存储变量及其相关且有唯一标识名称的容器。

 序列是存储有序变量的容器。存储的变量可以通过数字索引来检索，索引通常从0开始。】

 FTL 标签 (FreeMarker模板的语言标签)： FTL标签和HTML标签有一些相似之处，但是它们是FreeMarker的指令，是不会在输出中打印的。 这些标签的名字以 # 开头
 FTL标签也被称为 指令。
 ${...}： FreeMarker将会输出真实的值来替换大括号内的表达式，这样的表达式被称为 interpolation(插值，译者注)。

 基本指令
 if 指令
 list 指令
 include 指令
 联合使用指令
 使用内建函数
 处理不存在的变量

 【不论在哪里引用变量，都可以指定一个默认值来避免变量丢失这种情况， 通过在变量名后面跟着一个 !(叹号，译者注)和默认值。 就像下面的这个例子，当 user 不存在于数据模型时, 模板将会将 user 的值表示为字符串 "visitor"。(当 user 存在时， 模板就会表现出 ${user} 的值)：

  <h1>Welcome ${user!"visitor"}!</h1>
  也可以在变量名后面通过放置 ?? 来询问一个变量是否存在。将它和 if 指令合并， 那么如果 user 变量不存在的话将会忽略整个问候的代码段：

  <#if user??><h1>Welcome ${user}!</h1></#if>】

  模板可接收对象及哈希表 序列 集合数据模型

  FTL是区分大小写的。 list 是指令的名称而 List 就不是。类似地 ${name} 和 ${Name} 或 ${NAME} 也是不同的。

  直接指定值
  字符串： "Foo" 或者 'Foo' 或者 "It's \"quoted\"" 或者 'It\'s "quoted"' 或者 r"C:\raw\string"
  数字： 123.45
  布尔值： true， false
  序列： ["foo", "bar", 123.45]； 值域： 0..9, 0..<10 (或 0..!10), 0..
  哈希表： {"name":"green mouse", "price":150}
  检索变量
  顶层变量： user
  从哈希表中检索数据： user.name， user["name"]
  从序列中检索数据： products[5]
  特殊变量： .main
  字符串操作
  插值(或连接)： "Hello ${user}!" (或 "Hello " + user + "!")
  获取一个字符： name[0]
  字符串切分： 包含结尾： name[0..4]，不包含结尾： name[0..<5]，基于长度(宽容处理)： name[0..*5]，去除开头： name[5..]
  序列操作
  连接： users + ["guest"]
  序列切分：包含结尾： products[20..29]， 不包含结尾： products[20..<30]，基于长度(宽容处理)： products[20..*10]，去除开头： products[20..]
  哈希表操作
  连接： passwords + { "joe": "secret42" }
  算术运算： (x * 1.5 + 10) / 2 - y % 100
  比较运算： x == y， x != y， x < y， x > y， x >= y， x <= y， x lt y， x lte y， x gt y， x gte y， 等等。。。。。。
  逻辑操作： !registered && (firstVisit || fromEurope)
  内建函数： name?upper_case, path?ensure_starts_with('/')
  方法调用： repeat("What", 3)
  处理不存在的值：
  默认值： name!"unknown" 或者 (user.name)!"unknown" 或者 name! 或者 (user.name)!
  检测不存在的值： name?? 或者 (user.name)??
  赋值操作： =, +=, -=, *=, /=, %=, ++, --

  ——————————————————
  在模板中定义变量：使用 assign 创建和替换变量： <#assign x = 1>  <#-- create variable x -->

当运行FTL模板时，就会有使用 assign 和 macro 指令创建的变量的集合(可能是空的)， 可以从 前一章 来看如何使用它们。 像这样的变量集合被称为 命名空间。 简单的情况下可以只使用一个命名空间，称之为 主命名空间。因为通常只使用该命名空间， 所以就没有意识到这点。

如果想创建可以重复使用的宏，函数和其他变量的集合， 通常用术语来说就是引用 库。 使用多个命名空间是必然的。只要考虑你在一些项目中， 或者想和他人共享使用的时候，你是否有一个很大的宏的集合。 但要确保库中没有宏（或其他变量）名和数据模型中变量同名， 而且也不能和模板中引用其他库中的变量同名是不可能的。 通常来说，变量因为名称冲突时也会相互冲突。 所以要为每个库中的变量使用不同的命名空间。
空白处理： 1剥离空白 2使用compress指令

 静态文件访问路径前最好加上/，以免访问不到