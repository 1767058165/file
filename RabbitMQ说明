常见队列实现优缺点

　　队列介质

　　　　1、数据库，例如mysql（可靠性高，易实现，速度慢）

　　　　2、缓存， 例如redis （速度快，单个消息报包过大时效率低）

　　　　3、消息系统，例如rabbitMq （专业性强，可靠，学习成本高）

　　消息处理触发机制

　　　　1、死循环方式读取：易实现，故障时无法及时恢复；（比较适合做秒杀，比较集中，运维集中维护）

　　　　2、定时任务：压力均分，有处理上限；目前比较流行的处理触发机制。（唯一的缺点是间隔和数据需要注意，不要等上一个任务没有完成下一个任务又开始了）

　　　　3、守护进程：类似于php-fpm 和php-cg,需要shell基础

RabbitMQ提供了可持久化的队列，能够在队列服务崩溃的时候，将未处理的消息持久化到磁盘上。

由于来不及同步处理，请求往往会发生堵塞，比如说，大量的insert，update之类的请求同时到达MySQL，直接导致无数的行锁表锁，甚至最后请求会堆积过多，从而触发too many connections错误。通过使用消息队列，我们可以异步处理请求，从而缓解系统的压力。

消息本质上是一种数据结构
消息队列可以用缓存实现

我们之前讲秒杀案例的时候提到了锁的机制，防止其他程序处理同一条记录，如果我们的系统架构非常的复杂，有多个程序实时的读取一个队列，或者我有多个发送程序，同时来操作一个或多个队列，甚至我还想这些程序分布在不同的机器上，这种情况下用redis队列就有些力不从心了。这种时候怎么办呢，我们就需要来引入一些更专业的消息队列系统，这些系统可以更好的来解决问题。

redis 和消息服务器 选择的最大区别是什么。

　　　　我的理解是Redis 是一个一个处理请求，redis属于单线程，它和消息服务器 IO 的实现方式不同，一个是同步一个是异步，而redis使用的是同步阻塞，而消息服务器使用的是异步非阻塞。

RabbitMQ 即一个消息队列，主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。

消息中间件在互联网公司的使用中越来越多，刚才还看到新闻阿里将RocketMQ捐献给了apache，当然了今天的主角还是讲RabbitMQ。消息中间件最主要的作用是解耦，中间件最标准的用法是生产者生产消息传送到队列，消费者从队列中拿取消息并处理，生产者不用关心是谁来消费，消费者不用关心谁在生产消息，从而达到解耦的目的。在分布式的系统中，消息队列也会被用在很多其它的方面，比如：分布式事务的支持，RPC的调用等等。

RabbitMQ是实现AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。RabbitMQ主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。

AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。

RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。


常用消息模式

      A. 与管道一样，每个数据块有一个最大长度的限制。
      B. 系统中所有队列所包含的全部数据块的总长度也有一个上限。

Linux系统中有两个宏定义:
 MSGMAX, 以字节为单位，定义了一条消息的最大长度。
 MSGMNB, 以字节为单位，定义了一个队列的最大长度。

RabbitMQ默认的服务端口是5672，管理后台的端口是15672
【Window安装RabbitMQ,RabbitMQ安装文件是64位的,所以Window系统必须是64位的.安装RabbitMQ之前必须首先安装Erlang开发语言.

 配置rabbitmq管理后台，执行
 C:\Program Files\RabbitMQ Server\rabbitmq_server-3.7.0\sbin\rabbitmq-plugins enable rabbitmq_management 命令

 通过浏览器访问RabbitMQ管理后台 http://localhost:15672/

 下载运行rabbitmq-server-3.6.5 版】


     Exchange

     我们在开篇的时候就留了一个坑，就是那个应用结构图里面，消费者Client A和消费者Client B是如何知道我发送的消息是给Queue1还是给Queue2，有没有过这个问题，那么我们就来解开这个面纱，看看到底是个什么构造。首先明确一点就是生产者产生的消息并不是直接发送给消息队列Queue的，而是要经过Exchange（交换器），由Exchange再将消息路由到一个或多个Queue，当然这里还会对不符合路由规则的消息进行丢弃掉，这里指的是后续要谈到的Exchange Type。那么Exchange是怎样将消息准确的推送到对应的Queue的呢？那么这里的功劳最大的当属Binding，RabbitMQ是通过Binding将Exchange和Queue链接在一起，这样Exchange就知道如何将消息准确的推送到Queue中去。简单示意图如下所示：


      在绑定（Binding）Exchange和Queue的同时，一般会指定一个Binding Key，生产者将消息发送给Exchange的时候，一般会产生一个Routing Key，当Routing Key和Binding Key对应上的时候，消息就会发送到对应的Queue中去。那么Exchange有四种类型，不同的类型有着不同的策略。也就是表明不同的类型将决定绑定的Queue不同，换言之就是说生产者发送了一个消息，Routing Key的规则是A，那么生产者会将Routing Key=A的消息推送到Exchange中，这时候Exchange中会有自己的规则，对应的规则去筛选生产者发来的消息，如果能够对应上Exchange的内部规则就将消息推送到对应的Queue中去。那么接下来就来详细讲解下Exchange里面类型。


Exchange 4  规则
类型名称	类型描述
fanout	把所有发送到该Exchange的消息路由到所有与它绑定的Queue中
direct	Routing Key==Binding Key
topic	我这里自己总结的简称模糊匹配(binding key中可以存在两种特殊字符“*”与“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）)
headers	Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。

如果我们希望即使在RabbitMQ服务重启的情况下，也不会丢失消息，我们可以将Queue与Message都设置为可持久化的（durable），这样可以保证绝大部分情况下我们的RabbitMQ消息不会丢失。当然还是会有一些小概率事件会导致消息丢失。


使用RabbitMQ来实现延迟任务队列
【
消息可靠总结

持久化

exchange要持久化
queue要持久化
message要持久化


消息确认

启动消费返回（@ReturnList注解，生产者就可以知道哪些消息没有发出去）
生产者和Server（broker）之间的消息确认
消费者和Server（broker）之间的消息确认
】


发送者->Exchange（交换器）->队列->消费者

MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。
