中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。
设计模式在软件开发中的两个主要用途。

工厂模式：2层架构，即可获取对象
抽象工厂模式：三层架构，即可获取对象

单例模式的几种实现方式

【建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

 一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。
 应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、JAVA 中的 StringBuilder。

 】

 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式(关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone())。

 适配器模式--这种类型的设计模式属于结构型模式-【 public void play(String audioType, String fileName) {
              if(audioType.equalsIgnoreCase("vlc")){
                 advancedMusicPlayer.playVlc(fileName);
              }else if(audioType.equalsIgnoreCase("mp4")){
                 advancedMusicPlayer.playMp4(fileName);
              }
           }】

 创建型模式-->对象怎么来
 结构型模式-->对象和谁有关
 行为型模式-->对象与对象在干嘛
 J2EE 模式-->对象合起来要干嘛（表现层,文中表示层个人感觉用的不准确）java是面向对象的语言,所以要搞好对象,模式（套路）就是用来更加好的搞对象滴。

 原型模式是通过拷贝一个现有对象生成新对象的。

 桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。

 过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来

 所谓组合模式，其实说的是对象包含对象的问题--使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。

 装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

 享元模式（Flyweight Pattern）主要用于减少创建对象的数量（查询hashmap），以减少内存占用和提高性能。

 代理模式为其他对象提供一种代理以控制对这个对象的访问。

责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链,在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。(//责任链中的下一个元素 protected AbstractLogger nextLogger;)

//用来构建框架体系

命令模式-通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。

解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。

迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

中介者模式

备忘录模式--优点： 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。

Observer 模式的定义：该模式定义了对象之间的一对多依赖关系，Subject 对象是一，Observer 对象是多。当 Subject 对象的状态发生改变时，所有依赖于该 Subject 对象的 Observer 对象都会得到通知，并且自动更新。

策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。

MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。

业务代表模式（Business Delegate Pattern）用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。

//组合实体模式:该类有多个实体组成(  public String[] getData(){ return new String[] {do1.getData(),do2.getData()}; })

数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。

前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。

前端控制器（Front Controller） - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。
调度器（Dispatcher） - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。
视图（View） - 视图是为请求而创建的对象。